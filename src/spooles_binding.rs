#[allow(warnings)]

/* automatically generated by rust-bindgen 0.59.2 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const MEMORY_DEBUG: u32 = 0;
pub const IP_NULL: u32 = 0;
pub const IP_FORWARD: u32 = 1;
pub const IP_BACKWARD: u32 = 2;
pub const I2OP_NULL: u32 = 0;
pub const I2OP_FORWARD: u32 = 1;
pub const I2OP_BACKWARD: u32 = 2;
pub const SPOOLES_INDICES_ONLY: u32 = 0;
pub const SPOOLES_REAL: u32 = 1;
pub const SPOOLES_COMPLEX: u32 = 2;
pub const SPOOLES_SYMMETRIC: u32 = 0;
pub const SPOOLES_HERMITIAN: u32 = 1;
pub const SPOOLES_NONSYMMETRIC: u32 = 2;
pub const SPOOLES_NO_PIVOTING: u32 = 0;
pub const SPOOLES_PIVOTING: u32 = 1;
pub const SPOOLES_BY_ROWS: u32 = 1;
pub const SPOOLES_BY_COLUMNS: u32 = 2;
pub const A2_STRICT_LOWER: u32 = 1;
pub const A2_LOWER: u32 = 2;
pub const A2_DIAGONAL: u32 = 3;
pub const A2_UPPER: u32 = 4;
pub const A2_STRICT_UPPER: u32 = 5;
pub const A2_ALL_ENTRIES: u32 = 6;
pub const A2_BY_ROWS: u32 = 0;
pub const A2_BY_COLUMNS: u32 = 1;
pub const IVL_NOTYPE: i32 = -1;
pub const IVL_CHUNKED: u32 = 1;
pub const IVL_SOLO: u32 = 2;
pub const IVL_UNKNOWN: u32 = 3;
pub const IVL_INCR: u32 = 1024;
pub const INPMTX_NO_TYPE: u32 = 0;
pub const INPMTX_BY_ROWS: u32 = 1;
pub const INPMTX_BY_COLUMNS: u32 = 2;
pub const INPMTX_BY_CHEVRONS: u32 = 3;
pub const INPMTX_CUSTOM: u32 = 4;
pub const INPMTX_NO_MODE: u32 = 0;
pub const INPMTX_RAW_DATA: u32 = 1;
pub const INPMTX_SORTED: u32 = 2;
pub const INPMTX_BY_VECTORS: u32 = 3;
pub const INPMTX_INDICES_ONLY: u32 = 0;
pub const INPMTX_REAL_ENTRIES: u32 = 1;
pub const INPMTX_COMPLEX_ENTRIES: u32 = 2;
pub const COORDS_BY_TUPLE: u32 = 1;
pub const COORDS_BY_COORD: u32 = 2;
pub const SUBMTX_DENSE_ROWS: u32 = 0;
pub const SUBMTX_DENSE_COLUMNS: u32 = 1;
pub const SUBMTX_SPARSE_ROWS: u32 = 2;
pub const SUBMTX_SPARSE_COLUMNS: u32 = 3;
pub const SUBMTX_SPARSE_TRIPLES: u32 = 4;
pub const SUBMTX_DENSE_SUBROWS: u32 = 5;
pub const SUBMTX_DENSE_SUBCOLUMNS: u32 = 6;
pub const SUBMTX_DIAGONAL: u32 = 7;
pub const SUBMTX_BLOCK_DIAGONAL_SYM: u32 = 8;
pub const SUBMTX_BLOCK_DIAGONAL_HERM: u32 = 9;
pub const CHV_STRICT_LOWER: u32 = 1;
pub const CHV_DIAGONAL: u32 = 2;
pub const CHV_STRICT_UPPER: u32 = 3;
pub const CHV_STRICT_LOWER_11: u32 = 4;
pub const CHV_LOWER_21: u32 = 5;
pub const CHV_STRICT_UPPER_11: u32 = 6;
pub const CHV_UPPER_12: u32 = 7;
pub const CHV_BY_ROWS: u32 = 0;
pub const CHV_BY_COLUMNS: u32 = 1;
pub const TT_NONE: u32 = 0;
pub const TT_SOLARIS: u32 = 1;
pub const TT_POSIX: u32 = 2;
pub const THREAD_TYPE: u32 = 2;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const NO_LOCK: u32 = 0;
pub const LOCK_IN_PROCESS: u32 = 1;
pub const LOCK_OVER_ALL_PROCESSES: u32 = 2;
pub const FRONTMTX_DENSE_FRONTS: u32 = 0;
pub const FRONTMTX_SPARSE_FRONTS: u32 = 1;
pub const FRONTMTX_1D_MODE: u32 = 1;
pub const FRONTMTX_2D_MODE: u32 = 2;
pub const LOCK_IN_ALL_PROCESSES: u32 = 2;
pub type size_t = libc::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: libc::c_int,
        __old: *const libc::c_char,
        __newfd: libc::c_int,
        __new: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __pfx: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut libc::c_void,
        __len: size_t,
        __modes: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut libc::c_char, __sizeloc: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: libc::c_int,
        __fmt: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(__w: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut size_t,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut size_t,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: libc::c_ulong,
        __n: libc::c_ulong,
        __stream: *mut FILE,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: libc::c_ulong,
        __n: libc::c_ulong,
        __s: *mut FILE,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut libc::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const libc::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const libc::c_char);
}
extern "C" {
    pub static mut sys_nerr: libc::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: libc::c_int) -> libc::c_int;
}
pub type wchar_t = libc::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = libc::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_schar,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: size_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn malloc(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn alloca(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(__status: libc::c_int, __arg: *mut libc::c_void),
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int);
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int);
}
extern "C" {
    pub fn _Exit(__status: libc::c_int);
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: libc::c_int,
        __buf: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: size_t) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: size_t) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut libc::c_char,
        __tokens: *const *mut libc::c_char,
        __valuep: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int) -> libc::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> libc::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> libc::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> libc::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut libc::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut libc::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: libc::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: libc::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const libc::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const libc::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> libc::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: libc::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: libc::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: libc::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: libc::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut libc::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut libc::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: libc::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: libc::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> libc::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: libc::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: libc::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut libc::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut libc::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> libc::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> libc::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> libc::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> libc::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> libc::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: libc::c_int;
}
// pub const FP_NAN: libc::c_uint = 0;
// pub const FP_INFINITE: libc::c_uint = 1;
// pub const FP_ZERO: libc::c_uint = 2;
// pub const FP_SUBNORMAL: libc::c_uint = 3;
// pub const FP_NORMAL: libc::c_uint = 4;
pub type _bindgen_ty_1 = libc::c_uint;
extern "C" {
    pub fn memcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __l: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: libc::c_ulong) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: locale_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: libc::c_ulong);
}
extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: size_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_ulong,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CVinit(size: libc::c_int, c: libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CVinit2(size: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn CVcopy(size: libc::c_int, y: *mut libc::c_char, x: *mut libc::c_char);
}
extern "C" {
    pub fn CVfill(size: libc::c_int, y: *mut libc::c_char, c: libc::c_char);
}
extern "C" {
    pub fn CVfprintf(fp: *mut FILE, size: libc::c_int, y: *mut libc::c_char);
}
extern "C" {
    pub fn CVfp80(
        fp: *mut FILE,
        size: libc::c_int,
        y: *mut libc::c_char,
        column: libc::c_int,
        pierr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CVfree(y: *mut libc::c_char);
}
extern "C" {
    pub fn CVfscanf(fp: *mut FILE, size: libc::c_int, y: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ZVdotU33(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotU32(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotU31(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotU23(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotU22(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotU21(n: libc::c_int, y0: *mut f64, y1: *mut f64, x0: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn ZVdotU13(
        n: libc::c_int,
        y0: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotU12(n: libc::c_int, y0: *mut f64, x0: *mut f64, x1: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn ZVdotU11(n: libc::c_int, y0: *mut f64, x0: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn ZVdotC33(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotC32(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotC31(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotC23(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotC22(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotC21(n: libc::c_int, y0: *mut f64, y1: *mut f64, x0: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn ZVdotC13(
        n: libc::c_int,
        y0: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotC12(n: libc::c_int, y0: *mut f64, x0: *mut f64, x1: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn ZVdotC11(n: libc::c_int, y0: *mut f64, x0: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn DVadd(size: libc::c_int, y: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn DVaxpy(size: libc::c_int, y: *mut f64, alpha: f64, x: *mut f64);
}
extern "C" {
    pub fn DVaxpyi(
        size: libc::c_int,
        y: *mut f64,
        index: *mut libc::c_int,
        alpha: f64,
        x: *mut f64,
    );
}
extern "C" {
    pub fn DVcopy(size: libc::c_int, y: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn DVcompress(
        size1: libc::c_int,
        x1: *mut f64,
        y1: *mut f64,
        size2: libc::c_int,
        x2: *mut f64,
        y2: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DVdot(size: libc::c_int, y: *mut f64, x: *mut f64) -> f64;
}
extern "C" {
    pub fn DVdoti(size: libc::c_int, y: *mut f64, index: *mut libc::c_int, x: *mut f64) -> f64;
}
extern "C" {
    pub fn DVfill(size: libc::c_int, y: *mut f64, dval: f64);
}
extern "C" {
    pub fn DVfprintf(fp: *mut FILE, size: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn DVfree(dvec: *mut f64);
}
extern "C" {
    pub fn DVfscanf(fp: *mut FILE, size: libc::c_int, y: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn DVgather(size: libc::c_int, y: *mut f64, x: *mut f64, index: *mut libc::c_int);
}
extern "C" {
    pub fn DVgatherAddZero(size: libc::c_int, y: *mut f64, x: *mut f64, index: *mut libc::c_int);
}
extern "C" {
    pub fn DVgatherZero(size: libc::c_int, y: *mut f64, x: *mut f64, index: *mut libc::c_int);
}
extern "C" {
    pub fn DVinit(size: libc::c_int, dval: f64) -> *mut f64;
}
extern "C" {
    pub fn DVinit2(size: libc::c_int) -> *mut f64;
}
extern "C" {
    pub fn DVinvPerm(size: libc::c_int, y: *mut f64, index: *mut libc::c_int);
}
extern "C" {
    pub fn DVmax(size: libc::c_int, y: *mut f64, ploc: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn DVmaxabs(size: libc::c_int, y: *mut f64, ploc: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn DVmin(size: libc::c_int, y: *mut f64, ploc: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn DVminabs(size: libc::c_int, y: *mut f64, ploc: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn DVperm(size: libc::c_int, y: *mut f64, index: *mut libc::c_int);
}
extern "C" {
    pub fn DVramp(size: libc::c_int, y: *mut f64, start: f64, inc: f64);
}
extern "C" {
    pub fn DVsub(size: libc::c_int, y: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn DVscale(size: libc::c_int, y: *mut f64, alpha: f64);
}
extern "C" {
    pub fn DVscatter(size: libc::c_int, y: *mut f64, index: *mut libc::c_int, x: *mut f64);
}
extern "C" {
    pub fn DVscatterAdd(size: libc::c_int, y: *mut f64, index: *mut libc::c_int, x: *mut f64);
}
extern "C" {
    pub fn DVscatterAddZero(size: libc::c_int, y: *mut f64, index: *mut libc::c_int, x: *mut f64);
}
extern "C" {
    pub fn DVscatterZero(size: libc::c_int, y: *mut f64, index: *mut libc::c_int, x: *mut f64);
}
extern "C" {
    pub fn DVsum(size: libc::c_int, y: *mut f64) -> f64;
}
extern "C" {
    pub fn DVsumabs(size: libc::c_int, y: *mut f64) -> f64;
}
extern "C" {
    pub fn DVswap(size: libc::c_int, y: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn DVzero(size: libc::c_int, y: *mut f64);
}
extern "C" {
    pub fn DVshuffle(size: libc::c_int, y: *mut f64, seed: libc::c_int);
}
extern "C" {
    pub fn DVscale2(size: libc::c_int, x: *mut f64, y: *mut f64, a: f64, b: f64, c: f64, d: f64);
}
extern "C" {
    pub fn DVaxpy2(size: libc::c_int, z: *mut f64, a: f64, x: *mut f64, b: f64, y: *mut f64);
}
extern "C" {
    pub fn DVdot33(
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        row2: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        col2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn DVdot23(
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        col2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn DVdot13(
        n: libc::c_int,
        row0: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        col2: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn DVdot32(
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        row2: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn DVdot22(
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn DVdot12(n: libc::c_int, row0: *mut f64, col0: *mut f64, col1: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn DVdot31(
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        row2: *mut f64,
        col0: *mut f64,
        sums: *mut f64,
    );
}
extern "C" {
    pub fn DVdot21(n: libc::c_int, row0: *mut f64, row1: *mut f64, col0: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn DVdot11(n: libc::c_int, row0: *mut f64, col0: *mut f64, sums: *mut f64);
}
extern "C" {
    pub fn FVadd(size: libc::c_int, y: *mut f32, x: *mut f32);
}
extern "C" {
    pub fn FVaxpy(size: libc::c_int, y: *mut f32, alpha: f32, x: *mut f32);
}
extern "C" {
    pub fn FVaxpyi(
        size: libc::c_int,
        y: *mut f32,
        index: *mut libc::c_int,
        alpha: f32,
        x: *mut f32,
    );
}
extern "C" {
    pub fn FVcopy(size: libc::c_int, y: *mut f32, x: *mut f32);
}
extern "C" {
    pub fn FVcompress(
        size1: libc::c_int,
        x1: *mut f32,
        y1: *mut f32,
        size2: libc::c_int,
        x2: *mut f32,
        y2: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn FVdot(size: libc::c_int, y: *mut f32, x: *mut f32) -> f32;
}
extern "C" {
    pub fn FVfill(size: libc::c_int, y: *mut f32, dval: f32);
}
extern "C" {
    pub fn FVfprintf(fp: *mut FILE, size: libc::c_int, y: *mut f32);
}
extern "C" {
    pub fn FVfree(y: *mut f32);
}
extern "C" {
    pub fn FVfscanf(fp: *mut FILE, size: libc::c_int, y: *mut f32) -> libc::c_int;
}
extern "C" {
    pub fn FVgather(size: libc::c_int, y: *mut f32, x: *mut f32, index: *mut libc::c_int);
}
extern "C" {
    pub fn FVgatherAddZero(size: libc::c_int, y: *mut f32, x: *mut f32, index: *mut libc::c_int);
}
extern "C" {
    pub fn FVgatherZero(size: libc::c_int, y: *mut f32, x: *mut f32, index: *mut libc::c_int);
}
extern "C" {
    pub fn FVinit(size: libc::c_int, dval: f32) -> *mut f32;
}
extern "C" {
    pub fn FVinit2(size: libc::c_int) -> *mut f32;
}
extern "C" {
    pub fn FVinvPerm(size: libc::c_int, y: *mut f32, index: *mut libc::c_int);
}
extern "C" {
    pub fn FVmax(size: libc::c_int, y: *mut f32, ploc: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn FVmaxabs(size: libc::c_int, y: *mut f32, ploc: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn FVmin(size: libc::c_int, y: *mut f32, ploc: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn FVminabs(size: libc::c_int, y: *mut f32, ploc: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn FVperm(size: libc::c_int, y: *mut f32, index: *mut libc::c_int);
}
extern "C" {
    pub fn FVramp(size: libc::c_int, y: *mut f32, start: f32, inc: f32);
}
extern "C" {
    pub fn FVsub(size: libc::c_int, y: *mut f32, x: *mut f32);
}
extern "C" {
    pub fn FVscale(size: libc::c_int, y: *mut f32, alpha: f32);
}
extern "C" {
    pub fn FVscatter(size: libc::c_int, y: *mut f32, index: *mut libc::c_int, x: *mut f32);
}
extern "C" {
    pub fn FVscatterAddZero(size: libc::c_int, y: *mut f32, index: *mut libc::c_int, x: *mut f32);
}
extern "C" {
    pub fn FVscatterZero(size: libc::c_int, y: *mut f32, index: *mut libc::c_int, x: *mut f32);
}
extern "C" {
    pub fn FVsum(size: libc::c_int, y: *mut f32) -> f32;
}
extern "C" {
    pub fn FVsumabs(size: libc::c_int, y: *mut f32) -> f32;
}
extern "C" {
    pub fn FVswap(size: libc::c_int, y: *mut f32, x: *mut f32);
}
extern "C" {
    pub fn FVzero(size: libc::c_int, y: *mut f32);
}
extern "C" {
    pub fn FVshuffle(size: libc::c_int, y: *mut f32, seed: libc::c_int);
}
extern "C" {
    pub fn IVcompress(
        size1: libc::c_int,
        x1: *mut libc::c_int,
        y1: *mut libc::c_int,
        size2: libc::c_int,
        x2: *mut libc::c_int,
        y2: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IVcopy(size: libc::c_int, y: *mut libc::c_int, x: *mut libc::c_int);
}
extern "C" {
    pub fn IVfill(size: libc::c_int, y: *mut libc::c_int, ival: libc::c_int);
}
extern "C" {
    pub fn IVfprintf(fp: *mut FILE, size: libc::c_int, y: *mut libc::c_int);
}
extern "C" {
    pub fn IVfp80(
        fp: *mut FILE,
        size: libc::c_int,
        y: *mut libc::c_int,
        column: libc::c_int,
        pierr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IVfree(y: *mut libc::c_int);
}
extern "C" {
    pub fn IVfscanf(fp: *mut FILE, size: libc::c_int, y: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVgather(
        size: libc::c_int,
        y: *mut libc::c_int,
        x: *mut libc::c_int,
        index: *mut libc::c_int,
    );
}
extern "C" {
    pub fn IVinit(size: libc::c_int, ival: libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn IVinit2(size: libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn IVinverse(size: libc::c_int, y: *mut libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn IVinvPerm(size: libc::c_int, y: *mut libc::c_int, index: *mut libc::c_int);
}
extern "C" {
    pub fn IVmax(size: libc::c_int, y: *mut libc::c_int, ploc: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVmaxabs(size: libc::c_int, y: *mut libc::c_int, ploc: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVmin(size: libc::c_int, y: *mut libc::c_int, ploc: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVminabs(size: libc::c_int, y: *mut libc::c_int, ploc: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVperm(size: libc::c_int, y: *mut libc::c_int, index: *mut libc::c_int);
}
extern "C" {
    pub fn IVramp(size: libc::c_int, y: *mut libc::c_int, start: libc::c_int, inc: libc::c_int);
}
extern "C" {
    pub fn IVscatter(
        size: libc::c_int,
        y: *mut libc::c_int,
        index: *mut libc::c_int,
        x: *mut libc::c_int,
    );
}
extern "C" {
    pub fn IVsum(size: libc::c_int, y: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVsumabs(size: libc::c_int, y: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVswap(size: libc::c_int, y: *mut libc::c_int, x: *mut libc::c_int);
}
extern "C" {
    pub fn IVzero(size: libc::c_int, y: *mut libc::c_int);
}
extern "C" {
    pub fn IVshuffle(size: libc::c_int, y: *mut libc::c_int, seed: libc::c_int);
}
extern "C" {
    pub fn IVlocateViaBinarySearch(
        size: libc::c_int,
        ivec: *mut libc::c_int,
        target: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn PCVfree(p_cvec: *mut *mut libc::c_char);
}
extern "C" {
    pub fn PCVinit(size: libc::c_int) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn PCVsetup(
        length: libc::c_int,
        sizes: *mut libc::c_int,
        cvec: *mut libc::c_char,
        p_cvec: *mut *mut libc::c_char,
    );
}
extern "C" {
    pub fn PCVcopy(
        length: libc::c_int,
        p_cvec1: *mut *mut libc::c_char,
        p_cvec2: *mut *mut libc::c_char,
    );
}
extern "C" {
    pub fn PDVfree(p_dvec: *mut *mut f64);
}
extern "C" {
    pub fn PDVinit(size: libc::c_int) -> *mut *mut f64;
}
extern "C" {
    pub fn PDVsetup(
        length: libc::c_int,
        sizes: *mut libc::c_int,
        dvec: *mut f64,
        p_dvec: *mut *mut f64,
    );
}
extern "C" {
    pub fn PDVcopy(length: libc::c_int, p_dvec1: *mut *mut f64, p_dvec2: *mut *mut f64);
}
extern "C" {
    pub fn PFVfree(p_fvec: *mut *mut f32);
}
extern "C" {
    pub fn PFVinit(size: libc::c_int) -> *mut *mut f32;
}
extern "C" {
    pub fn PFVsetup(
        length: libc::c_int,
        sizes: *mut libc::c_int,
        fvec: *mut f32,
        p_fvec: *mut *mut f32,
    );
}
extern "C" {
    pub fn PFVcopy(length: libc::c_int, p_fvec1: *mut *mut f32, p_fvec2: *mut *mut f32);
}
extern "C" {
    pub fn PIVfree(p_ivec: *mut *mut libc::c_int);
}
extern "C" {
    pub fn PIVinit(size: libc::c_int) -> *mut *mut libc::c_int;
}
extern "C" {
    pub fn PIVsetup(
        length: libc::c_int,
        sizes: *mut libc::c_int,
        ivec: *mut libc::c_int,
        p_ivec: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn PIVcopy(
        length: libc::c_int,
        p_ivec1: *mut *mut libc::c_int,
        p_ivec2: *mut *mut libc::c_int,
    );
}
pub type IP = _IP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IP {
    pub val: libc::c_int,
    pub next: *mut IP,
}
#[test]
fn bindgen_test_layout__IP() {
    assert_eq!(
        ::std::mem::size_of::<_IP>(),
        16usize,
        concat!("Size of: ", stringify!(_IP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IP>())).val as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IP), "::", stringify!(val))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IP>())).next as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IP), "::", stringify!(next))
    );
}
extern "C" {
    pub fn IP_fprintf(fp: *mut FILE, ip: *mut IP);
}
extern "C" {
    pub fn IP_fp80(fp: *mut FILE, ip: *mut IP, column: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IP_init(n: libc::c_int, flag: libc::c_int) -> *mut IP;
}
extern "C" {
    pub fn IP_free(ip: *mut IP);
}
extern "C" {
    pub fn IP_mergeUp(ip1: *mut IP, ip2: *mut IP) -> *mut IP;
}
extern "C" {
    pub fn IP_radixSortUp(ip: *mut IP) -> *mut IP;
}
extern "C" {
    pub fn IP_radixSortDown(ip: *mut IP) -> *mut IP;
}
extern "C" {
    pub fn IP_mergeSortUp(ip0: *mut IP) -> *mut IP;
}
pub type I2OP = _I2OP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _I2OP {
    pub value0: libc::c_int,
    pub value1: libc::c_int,
    pub value2: *mut libc::c_void,
    pub next: *mut I2OP,
}
#[test]
fn bindgen_test_layout__I2OP() {
    assert_eq!(
        ::std::mem::size_of::<_I2OP>(),
        24usize,
        concat!("Size of: ", stringify!(_I2OP))
    );
    assert_eq!(
        ::std::mem::align_of::<_I2OP>(),
        8usize,
        concat!("Alignment of ", stringify!(_I2OP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2OP>())).value0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2OP),
            "::",
            stringify!(value0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2OP>())).value1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2OP),
            "::",
            stringify!(value1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2OP>())).value2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2OP),
            "::",
            stringify!(value2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2OP>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2OP),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn I2OP_init(n: libc::c_int, flag: libc::c_int) -> *mut I2OP;
}
extern "C" {
    pub fn I2OP_initStorage(n: libc::c_int, flag: libc::c_int, base: *mut I2OP);
}
extern "C" {
    pub fn I2OP_free(ip: *mut I2OP);
}
extern "C" {
    pub fn I2OP_fprintf(fp: *mut FILE, elem: *mut I2OP);
}
extern "C" {
    pub fn IVisascending(n: libc::c_int, ivec: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVisdescending(n: libc::c_int, ivec: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn DVisascending(n: libc::c_int, dvec: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn DVisdescending(n: libc::c_int, dvec: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn IVisortUp(n: libc::c_int, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn IV2isortUp(n: libc::c_int, ivec1: *mut libc::c_int, ivec2: *mut libc::c_int);
}
extern "C" {
    pub fn IV2isortDown(n: libc::c_int, ivec1: *mut libc::c_int, ivec2: *mut libc::c_int);
}
extern "C" {
    pub fn IVDVisortUp(n: libc::c_int, ivec: *mut libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn IVDVisortDown(n: libc::c_int, ivec: *mut libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn IVisortDown(n: libc::c_int, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn IV2DVisortUp(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        dvec: *mut f64,
    );
}
extern "C" {
    pub fn IV2DVisortDown(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        dvec: *mut f64,
    );
}
extern "C" {
    pub fn IVZVisortUp(n: libc::c_int, ivec: *mut libc::c_int, zvec: *mut f64);
}
extern "C" {
    pub fn IVZVisortDown(n: libc::c_int, ivec: *mut libc::c_int, zvec: *mut f64);
}
extern "C" {
    pub fn IV2ZVisortUp(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        zvec: *mut f64,
    );
}
extern "C" {
    pub fn IV2ZVisortDown(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        zvec: *mut f64,
    );
}
extern "C" {
    pub fn DVisortUp(n: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn DVisortDown(n: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn DV2isortUp(n: libc::c_int, dvec1: *mut f64, dvec2: *mut f64);
}
extern "C" {
    pub fn DV2isortDown(n: libc::c_int, dvec1: *mut f64, dvec2: *mut f64);
}
extern "C" {
    pub fn DVIVisortUp(n: libc::c_int, dvec: *mut f64, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn DVIVisortDown(n: libc::c_int, dvec: *mut f64, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn IVqsortUp(n: libc::c_int, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn IVqsortDown(n: libc::c_int, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn IV2qsortUp(n: libc::c_int, ivec1: *mut libc::c_int, ivec2: *mut libc::c_int);
}
extern "C" {
    pub fn IV2qsortDown(n: libc::c_int, ivec1: *mut libc::c_int, ivec2: *mut libc::c_int);
}
extern "C" {
    pub fn IVDVqsortUp(n: libc::c_int, ivec: *mut libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn IVDVqsortDown(n: libc::c_int, ivec: *mut libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn IV2DVqsortUp(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        dvec: *mut f64,
    );
}
extern "C" {
    pub fn IV2DVqsortDown(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        dvec: *mut f64,
    );
}
extern "C" {
    pub fn IVZVqsortUp(n: libc::c_int, ivec: *mut libc::c_int, zvec: *mut f64);
}
extern "C" {
    pub fn IVZVqsortDown(n: libc::c_int, ivec: *mut libc::c_int, zvec: *mut f64);
}
extern "C" {
    pub fn IV2ZVqsortUp(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        zvec: *mut f64,
    );
}
extern "C" {
    pub fn IV2ZVqsortDown(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        zvec: *mut f64,
    );
}
extern "C" {
    pub fn DVqsortUp(n: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn DVqsortDown(n: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn DV2qsortUp(n: libc::c_int, dvec1: *mut f64, dvec2: *mut f64);
}
extern "C" {
    pub fn DV2qsortDown(n: libc::c_int, dvec1: *mut f64, dvec2: *mut f64);
}
extern "C" {
    pub fn DVIVqsortUp(n: libc::c_int, dvec: *mut f64, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn DVIVqsortDown(n: libc::c_int, dvec: *mut f64, ivec: *mut libc::c_int);
}
extern "C" {
    pub fn IVsortUpAndCompress(n: libc::c_int, ivec: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IVDVsortUpAndCompress(
        n: libc::c_int,
        ivec: *mut libc::c_int,
        dvec: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IVZVsortUpAndCompress(
        n: libc::c_int,
        ivec: *mut libc::c_int,
        zvec: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IV2sortUpAndCompress(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IV2DVsortUpAndCompress(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        dvec: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IV2ZVsortUpAndCompress(
        n: libc::c_int,
        ivec1: *mut libc::c_int,
        ivec2: *mut libc::c_int,
        zvec: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mdot3x3(
        sums: *mut f64,
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        row2: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        col2: *mut f64,
    );
}
extern "C" {
    pub fn mdot2x3(
        sums: *mut f64,
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        col2: *mut f64,
    );
}
extern "C" {
    pub fn mdot1x3(
        sums: *mut f64,
        n: libc::c_int,
        row0: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
        col2: *mut f64,
    );
}
extern "C" {
    pub fn mdot3x2(
        sums: *mut f64,
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        row2: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
    );
}
extern "C" {
    pub fn mdot2x2(
        sums: *mut f64,
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        col0: *mut f64,
        col1: *mut f64,
    );
}
extern "C" {
    pub fn mdot1x2(sums: *mut f64, n: libc::c_int, row0: *mut f64, col0: *mut f64, col1: *mut f64);
}
extern "C" {
    pub fn mdot3x1(
        sums: *mut f64,
        n: libc::c_int,
        row0: *mut f64,
        row1: *mut f64,
        row2: *mut f64,
        col0: *mut f64,
    );
}
extern "C" {
    pub fn mdot2x1(sums: *mut f64, n: libc::c_int, row0: *mut f64, row1: *mut f64, col0: *mut f64);
}
extern "C" {
    pub fn mdot1x1(sums: *mut f64, n: libc::c_int, row0: *mut f64, col0: *mut f64);
}
extern "C" {
    pub fn IV2sortAndCount(
        nobs: libc::c_int,
        x: *mut libc::c_int,
        y: *mut libc::c_int,
        pndistinct: *mut libc::c_int,
        pxdistinct: *mut *mut libc::c_int,
        pydistinct: *mut *mut libc::c_int,
        pcounts: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn Zabs(real: f64, imag: f64) -> f64;
}
extern "C" {
    pub fn Zrecip(areal: f64, aimag: f64, preal: *mut f64, pimag: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn Zrecip2(
        areal: f64,
        aimag: f64,
        breal: f64,
        bimag: f64,
        creal: f64,
        cimag: f64,
        dreal: f64,
        dimag: f64,
        pereal: *mut f64,
        peimag: *mut f64,
        pfreal: *mut f64,
        pfimag: *mut f64,
        pgreal: *mut f64,
        pgimag: *mut f64,
        phreal: *mut f64,
        phimag: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ZVinit(n: libc::c_int, real: f64, imag: f64) -> *mut f64;
}
extern "C" {
    pub fn ZVdotU(size: libc::c_int, y: *mut f64, x: *mut f64, prdot: *mut f64, pidot: *mut f64);
}
extern "C" {
    pub fn ZVdotC(size: libc::c_int, y: *mut f64, x: *mut f64, prdot: *mut f64, pidot: *mut f64);
}
extern "C" {
    pub fn ZVdotiU(
        size: libc::c_int,
        y: *mut f64,
        index: *mut libc::c_int,
        x: *mut f64,
        prdot: *mut f64,
        pidot: *mut f64,
    );
}
extern "C" {
    pub fn ZVdotiC(
        size: libc::c_int,
        y: *mut f64,
        index: *mut libc::c_int,
        x: *mut f64,
        prdot: *mut f64,
        pidot: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy(size: libc::c_int, y: *mut f64, areal: f64, aimag: f64, x: *mut f64);
}
extern "C" {
    pub fn ZVaxpy2(
        size: libc::c_int,
        z: *mut f64,
        areal: f64,
        aimag: f64,
        x: *mut f64,
        breal: f64,
        bimag: f64,
        y: *mut f64,
    );
}
extern "C" {
    pub fn ZVscale(size: libc::c_int, y: *mut f64, areal: f64, aimag: f64);
}
extern "C" {
    pub fn ZVscale2(
        size: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        d00r: f64,
        d00i: f64,
        d01r: f64,
        d01i: f64,
        d10r: f64,
        d10i: f64,
        d11r: f64,
        d11i: f64,
    );
}
extern "C" {
    pub fn ZVfprintf(fp: *mut FILE, size: libc::c_int, y: *mut f64);
}
extern "C" {
    pub fn ZVminabs(size: libc::c_int, x: *mut f64) -> f64;
}
extern "C" {
    pub fn ZVmaxabs(size: libc::c_int, x: *mut f64) -> f64;
}
extern "C" {
    pub fn ZVcopy(size: libc::c_int, y: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn ZVsub(size: libc::c_int, y: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn ZVgather(size: libc::c_int, y: *mut f64, x: *mut f64, index: *mut libc::c_int);
}
extern "C" {
    pub fn ZVscatter(size: libc::c_int, y: *mut f64, index: *mut libc::c_int, x: *mut f64);
}
extern "C" {
    pub fn ZVzero(size: libc::c_int, y: *mut f64);
}
extern "C" {
    pub fn readHB_info(
        filename: *const libc::c_char,
        M: *mut libc::c_int,
        N: *mut libc::c_int,
        nz: *mut libc::c_int,
        Type: *mut *mut libc::c_char,
        Nrhs: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_header(
        in_file: *mut FILE,
        Title: *mut libc::c_char,
        Key: *mut libc::c_char,
        Type: *mut libc::c_char,
        Nrow: *mut libc::c_int,
        Ncol: *mut libc::c_int,
        Nnzero: *mut libc::c_int,
        Nrhs: *mut libc::c_int,
        Ptrfmt: *mut libc::c_char,
        Indfmt: *mut libc::c_char,
        Valfmt: *mut libc::c_char,
        Rhsfmt: *mut libc::c_char,
        Ptrcrd: *mut libc::c_int,
        Indcrd: *mut libc::c_int,
        Valcrd: *mut libc::c_int,
        Rhscrd: *mut libc::c_int,
        Rhstype: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_newmat_double(
        filename: *const libc::c_char,
        M: *mut libc::c_int,
        N: *mut libc::c_int,
        nz: *mut libc::c_int,
        colptr: *mut *mut libc::c_int,
        rowind: *mut *mut libc::c_int,
        val: *mut *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_mat_double(
        filename: *const libc::c_char,
        colptr: *mut libc::c_int,
        rowind: *mut libc::c_int,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_aux_double(
        filename: *const libc::c_char,
        AuxType: libc::c_char,
        b: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_newaux_double(
        filename: *const libc::c_char,
        AuxType: libc::c_char,
        b: *mut *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn writeHB_mat_double(
        filename: *const libc::c_char,
        M: libc::c_int,
        N: libc::c_int,
        nz: libc::c_int,
        colptr: *const libc::c_int,
        rowind: *const libc::c_int,
        val: *const f64,
        Nrhs: libc::c_int,
        rhs: *const f64,
        guess: *const f64,
        exact: *const f64,
        Title: *const libc::c_char,
        Key: *const libc::c_char,
        Type: *const libc::c_char,
        Ptrfmt: *mut libc::c_char,
        Indfmt: *mut libc::c_char,
        Valfmt: *mut libc::c_char,
        Rhsfmt: *mut libc::c_char,
        Rhstype: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_mat_char(
        filename: *const libc::c_char,
        colptr: *mut libc::c_int,
        rowind: *mut libc::c_int,
        val: *mut libc::c_char,
        Valfmt: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_newmat_char(
        filename: *const libc::c_char,
        M: *mut libc::c_int,
        N: *mut libc::c_int,
        nonzeros: *mut libc::c_int,
        colptr: *mut *mut libc::c_int,
        rowind: *mut *mut libc::c_int,
        val: *mut *mut libc::c_char,
        Valfmt: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_aux_char(
        filename: *const libc::c_char,
        AuxType: libc::c_char,
        b: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readHB_newaux_char(
        filename: *const libc::c_char,
        AuxType: libc::c_char,
        b: *mut *mut libc::c_char,
        Rhsfmt: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn writeHB_mat_char(
        filename: *const libc::c_char,
        M: libc::c_int,
        N: libc::c_int,
        nz: libc::c_int,
        colptr: *const libc::c_int,
        rowind: *const libc::c_int,
        val: *const libc::c_char,
        Nrhs: libc::c_int,
        rhs: *const libc::c_char,
        guess: *const libc::c_char,
        exact: *const libc::c_char,
        Title: *const libc::c_char,
        Key: *const libc::c_char,
        Type: *const libc::c_char,
        Ptrfmt: *mut libc::c_char,
        Indfmt: *mut libc::c_char,
        Valfmt: *mut libc::c_char,
        Rhsfmt: *mut libc::c_char,
        Rhstype: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DVaxpy33(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn DVaxpy32(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
    );
}
extern "C" {
    pub fn DVaxpy31(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
    );
}
extern "C" {
    pub fn DVaxpy23(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn DVaxpy22(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
    );
}
extern "C" {
    pub fn DVaxpy21(n: libc::c_int, y0: *mut f64, y1: *mut f64, alpha: *mut f64, x0: *mut f64);
}
extern "C" {
    pub fn DVaxpy13(
        n: libc::c_int,
        y0: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn DVaxpy12(n: libc::c_int, y0: *mut f64, alpha: *mut f64, x0: *mut f64, x1: *mut f64);
}
extern "C" {
    pub fn DVaxpy11(n: libc::c_int, y0: *mut f64, alpha: *mut f64, x0: *mut f64);
}
extern "C" {
    pub fn ZVaxpy33(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy32(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy31(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy23(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy22(
        n: libc::c_int,
        y0: *mut f64,
        y1: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy21(n: libc::c_int, y0: *mut f64, y1: *mut f64, alpha: *mut f64, x0: *mut f64);
}
extern "C" {
    pub fn ZVaxpy13(
        n: libc::c_int,
        y0: *mut f64,
        alpha: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn ZVaxpy12(n: libc::c_int, y0: *mut f64, alpha: *mut f64, x0: *mut f64, x1: *mut f64);
}
extern "C" {
    pub fn ZVaxpy11(n: libc::c_int, y0: *mut f64, alpha: *mut f64, x0: *mut f64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Drand {
    pub seed1: f64,
    pub seed2: f64,
    pub base1: f64,
    pub base2: f64,
    pub lower: f64,
    pub upper: f64,
    pub mean: f64,
    pub sigma: f64,
    pub mode: libc::c_int,
}
#[test]
fn bindgen_test_layout__Drand() {
    assert_eq!(
        ::std::mem::size_of::<_Drand>(),
        72usize,
        concat!("Size of: ", stringify!(_Drand))
    );
    assert_eq!(
        ::std::mem::align_of::<_Drand>(),
        8usize,
        concat!("Alignment of ", stringify!(_Drand))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).seed1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(seed1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).seed2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(seed2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).base1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(base1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).base2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(base2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).lower as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).upper as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(upper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).mean as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(mean)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).sigma as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(sigma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Drand>())).mode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_Drand),
            "::",
            stringify!(mode)
        )
    );
}
pub type Drand = _Drand;
extern "C" {
    pub fn Drand_new() -> *mut Drand;
}
extern "C" {
    pub fn Drand_setDefaultFields(drand: *mut Drand);
}
extern "C" {
    pub fn Drand_clearData(drand: *mut Drand);
}
extern "C" {
    pub fn Drand_free(drand: *mut Drand) -> *mut Drand;
}
extern "C" {
    pub fn Drand_init(drand: *mut Drand);
}
extern "C" {
    pub fn Drand_setSeed(drand: *mut Drand, u: libc::c_int);
}
extern "C" {
    pub fn Drand_setSeeds(drand: *mut Drand, u: libc::c_int, v: libc::c_int);
}
extern "C" {
    pub fn Drand_setUniform(drand: *mut Drand, lower: f64, upper: f64);
}
extern "C" {
    pub fn Drand_setNormal(drand: *mut Drand, mean: f64, sigma: f64);
}
extern "C" {
    pub fn Drand_value(drand: *mut Drand) -> f64;
}
extern "C" {
    pub fn Drand_fillZvector(drand: *mut Drand, size: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn Drand_fillDvector(drand: *mut Drand, size: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn Drand_fillIvector(drand: *mut Drand, size: libc::c_int, ivec: *mut libc::c_int);
}
pub type DV = _DV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DV {
    pub size: libc::c_int,
    pub maxsize: libc::c_int,
    pub owned: libc::c_int,
    pub vec: *mut f64,
}
#[test]
fn bindgen_test_layout__DV() {
    assert_eq!(
        ::std::mem::size_of::<_DV>(),
        24usize,
        concat!("Size of: ", stringify!(_DV))
    );
    assert_eq!(
        ::std::mem::align_of::<_DV>(),
        8usize,
        concat!("Alignment of ", stringify!(_DV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DV>())).size as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_DV), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DV>())).maxsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DV),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DV>())).owned as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DV),
            "::",
            stringify!(owned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DV>())).vec as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_DV), "::", stringify!(vec))
    );
}
extern "C" {
    pub fn DV_new() -> *mut DV;
}
extern "C" {
    pub fn DV_setDefaultFields(dv: *mut DV);
}
extern "C" {
    pub fn DV_clearData(dv: *mut DV);
}
extern "C" {
    pub fn DV_free(dv: *mut DV);
}
extern "C" {
    pub fn DV_init(iv: *mut DV, size: libc::c_int, entries: *mut f64);
}
extern "C" {
    pub fn DV_init1(dv: *mut DV, Maxsize: libc::c_int);
}
extern "C" {
    pub fn DV_init2(
        dv: *mut DV,
        Size: libc::c_int,
        Maxsize: libc::c_int,
        owned: libc::c_int,
        Dvec: *mut f64,
    );
}
extern "C" {
    pub fn DV_setMaxsize(dv: *mut DV, newmaxsize: libc::c_int);
}
extern "C" {
    pub fn DV_setSize(dv: *mut DV, newsize: libc::c_int);
}
extern "C" {
    pub fn DV_owned(dv: *mut DV) -> libc::c_int;
}
extern "C" {
    pub fn DV_maxsize(dv: *mut DV) -> libc::c_int;
}
extern "C" {
    pub fn DV_size(dv: *mut DV) -> libc::c_int;
}
extern "C" {
    pub fn DV_entry(dv: *mut DV, loc: libc::c_int) -> f64;
}
extern "C" {
    pub fn DV_entries(dv: *mut DV) -> *mut f64;
}
extern "C" {
    pub fn DV_sizeAndEntries(dv: *mut DV, psize: *mut libc::c_int, pentries: *mut *mut f64);
}
extern "C" {
    pub fn DV_setEntry(dv: *mut DV, loc: libc::c_int, value: f64);
}
extern "C" {
    pub fn DV_shiftBase(dv: *mut DV, offset: libc::c_int);
}
extern "C" {
    pub fn DV_resize(dv: *mut DV, Maxsize: libc::c_int);
}
extern "C" {
    pub fn DV_clear(dv: *mut DV);
}
extern "C" {
    pub fn DV_push(dv: *mut DV, val: f64);
}
extern "C" {
    pub fn DV_min(dv: *mut DV) -> f64;
}
extern "C" {
    pub fn DV_max(dv: *mut DV) -> f64;
}
extern "C" {
    pub fn DV_sum(dv: *mut DV) -> f64;
}
extern "C" {
    pub fn DV_sortUp(dv: *mut DV);
}
extern "C" {
    pub fn DV_sortDown(dv: *mut DV);
}
extern "C" {
    pub fn DV_ramp(dv: *mut DV, base: f64, incr: f64);
}
extern "C" {
    pub fn DV_shuffle(dv: *mut DV, seed: libc::c_int);
}
extern "C" {
    pub fn DV_sizeOf(dv: *mut DV) -> libc::c_int;
}
extern "C" {
    pub fn DV_first(dv: *mut DV) -> *mut f64;
}
extern "C" {
    pub fn DV_next(dv: *mut DV, pi: *mut f64) -> *mut f64;
}
extern "C" {
    pub fn DV_fill(dv: *mut DV, value: f64);
}
extern "C" {
    pub fn DV_zero(dv: *mut DV);
}
extern "C" {
    pub fn DV_copy(dv1: *mut DV, dv2: *mut DV);
}
extern "C" {
    pub fn DV_log10profile(
        dv: *mut DV,
        npts: libc::c_int,
        xDV: *mut DV,
        yDV: *mut DV,
        tausmall: f64,
        taubig: f64,
        pnzero: *mut libc::c_int,
        pnsmall: *mut libc::c_int,
        pnbig: *mut libc::c_int,
    );
}
extern "C" {
    pub fn DV_readFromFile(dv: *mut DV, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn DV_readFromFormattedFile(dv: *mut DV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DV_readFromBinaryFile(dv: *mut DV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DV_writeToFile(dv: *mut DV, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn DV_writeToFormattedFile(dv: *mut DV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DV_writeToBinaryFile(dv: *mut DV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DV_writeForHumanEye(dv: *mut DV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DV_writeStats(dv: *mut DV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DV_fp80(
        dv: *mut DV,
        fp: *mut FILE,
        column: libc::c_int,
        pierr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DV_writeForMatlab(dv: *mut DV, name: *mut libc::c_char, fp: *mut FILE) -> libc::c_int;
}
pub type ZV = _ZV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ZV {
    pub size: libc::c_int,
    pub maxsize: libc::c_int,
    pub owned: libc::c_int,
    pub vec: *mut f64,
}
#[test]
fn bindgen_test_layout__ZV() {
    assert_eq!(
        ::std::mem::size_of::<_ZV>(),
        24usize,
        concat!("Size of: ", stringify!(_ZV))
    );
    assert_eq!(
        ::std::mem::align_of::<_ZV>(),
        8usize,
        concat!("Alignment of ", stringify!(_ZV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ZV>())).size as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_ZV), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ZV>())).maxsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ZV),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ZV>())).owned as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ZV),
            "::",
            stringify!(owned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ZV>())).vec as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_ZV), "::", stringify!(vec))
    );
}
extern "C" {
    pub fn ZV_new() -> *mut ZV;
}
extern "C" {
    pub fn ZV_setDefaultFields(zv: *mut ZV);
}
extern "C" {
    pub fn ZV_clearData(zv: *mut ZV);
}
extern "C" {
    pub fn ZV_free(zv: *mut ZV);
}
extern "C" {
    pub fn ZV_init(zv: *mut ZV, size: libc::c_int, entries: *mut f64);
}
extern "C" {
    pub fn ZV_init1(zv: *mut ZV, size: libc::c_int);
}
extern "C" {
    pub fn ZV_init2(
        zv: *mut ZV,
        size: libc::c_int,
        maxsize: libc::c_int,
        owned: libc::c_int,
        vec: *mut f64,
    );
}
extern "C" {
    pub fn ZV_setMaxsize(zv: *mut ZV, newmaxsize: libc::c_int);
}
extern "C" {
    pub fn ZV_setSize(zv: *mut ZV, newsize: libc::c_int);
}
extern "C" {
    pub fn ZV_owned(dv: *mut ZV) -> libc::c_int;
}
extern "C" {
    pub fn ZV_maxsize(dv: *mut ZV) -> libc::c_int;
}
extern "C" {
    pub fn ZV_size(dv: *mut ZV) -> libc::c_int;
}
extern "C" {
    pub fn ZV_entry(dv: *mut ZV, loc: libc::c_int, pReal: *mut f64, pImag: *mut f64);
}
extern "C" {
    pub fn ZV_pointersToEntry(
        dv: *mut ZV,
        loc: libc::c_int,
        ppReal: *mut *mut f64,
        ppImag: *mut *mut f64,
    );
}
extern "C" {
    pub fn ZV_entries(dv: *mut ZV) -> *mut f64;
}
extern "C" {
    pub fn ZV_sizeAndEntries(dv: *mut ZV, psize: *mut libc::c_int, pentries: *mut *mut f64);
}
extern "C" {
    pub fn ZV_setEntry(dv: *mut ZV, loc: libc::c_int, real: f64, imag: f64);
}
extern "C" {
    pub fn ZV_shiftBase(zv: *mut ZV, offset: libc::c_int);
}
extern "C" {
    pub fn ZV_push(zv: *mut ZV, real: f64, imag: f64);
}
extern "C" {
    pub fn ZV_minabs(zv: *mut ZV) -> f64;
}
extern "C" {
    pub fn ZV_sizeOf(zv: *mut ZV) -> libc::c_int;
}
extern "C" {
    pub fn ZV_fill(zv: *mut ZV, real: f64, imag: f64);
}
extern "C" {
    pub fn ZV_zero(zv: *mut ZV);
}
extern "C" {
    pub fn ZV_copy(zv1: *mut ZV, zv2: *mut ZV);
}
extern "C" {
    pub fn ZV_log10profile(
        zv: *mut ZV,
        npts: libc::c_int,
        xDV: *mut DV,
        yDV: *mut DV,
        tausmall: f64,
        taubig: f64,
        pnzero: *mut libc::c_int,
        pnsmall: *mut libc::c_int,
        pnbig: *mut libc::c_int,
    );
}
extern "C" {
    pub fn ZV_readFromFile(zv: *mut ZV, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ZV_readFromFormattedFile(zv: *mut ZV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ZV_readFromBinaryFile(zv: *mut ZV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ZV_writeToFile(zv: *mut ZV, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ZV_writeToFormattedFile(zv: *mut ZV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ZV_writeToBinaryFile(zv: *mut ZV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ZV_writeForHumanEye(zv: *mut ZV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ZV_writeStats(zv: *mut ZV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ZV_writeForMatlab(zv: *mut ZV, vecname: *mut libc::c_char, fp: *mut FILE);
}
pub type IV = _IV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IV {
    pub size: libc::c_int,
    pub maxsize: libc::c_int,
    pub owned: libc::c_int,
    pub vec: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout__IV() {
    assert_eq!(
        ::std::mem::size_of::<_IV>(),
        24usize,
        concat!("Size of: ", stringify!(_IV))
    );
    assert_eq!(
        ::std::mem::align_of::<_IV>(),
        8usize,
        concat!("Alignment of ", stringify!(_IV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IV>())).size as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IV), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IV>())).maxsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IV),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IV>())).owned as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IV),
            "::",
            stringify!(owned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IV>())).vec as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IV), "::", stringify!(vec))
    );
}
extern "C" {
    pub fn IV_new() -> *mut IV;
}
extern "C" {
    pub fn IV_setDefaultFields(iv: *mut IV);
}
extern "C" {
    pub fn IV_clearData(iv: *mut IV);
}
extern "C" {
    pub fn IV_free(iv: *mut IV);
}
extern "C" {
    pub fn IV_init(iv: *mut IV, size: libc::c_int, entries: *mut libc::c_int);
}
extern "C" {
    pub fn IV_init1(iv: *mut IV, Maxsize: libc::c_int);
}
extern "C" {
    pub fn IV_init2(
        iv: *mut IV,
        size: libc::c_int,
        maxsize: libc::c_int,
        owned: libc::c_int,
        vec: *mut libc::c_int,
    );
}
extern "C" {
    pub fn IV_setMaxsize(iv: *mut IV, newmaxsize: libc::c_int);
}
extern "C" {
    pub fn IV_setSize(iv: *mut IV, newsize: libc::c_int);
}
extern "C" {
    pub fn IV_owned(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_size(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_maxsize(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_entry(iv: *mut IV, loc: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IV_entries(iv: *mut IV) -> *mut libc::c_int;
}
extern "C" {
    pub fn IV_sizeAndEntries(iv: *mut IV, psize: *mut libc::c_int, pentries: *mut *mut libc::c_int);
}
extern "C" {
    pub fn IV_setEntry(iv: *mut IV, location: libc::c_int, value: libc::c_int);
}
extern "C" {
    pub fn IV_shiftBase(iv: *mut IV, offset: libc::c_int);
}
extern "C" {
    pub fn IV_push(iv: *mut IV, val: libc::c_int);
}
extern "C" {
    pub fn IV_min(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_max(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_sum(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_sortUp(iv: *mut IV);
}
extern "C" {
    pub fn IV_sortDown(iv: *mut IV);
}
extern "C" {
    pub fn IV_ramp(iv: *mut IV, base: libc::c_int, incr: libc::c_int);
}
extern "C" {
    pub fn IV_shuffle(iv: *mut IV, seed: libc::c_int);
}
extern "C" {
    pub fn IV_sizeOf(iv: *mut IV) -> libc::c_int;
}
extern "C" {
    pub fn IV_filterKeep(iv: *mut IV, tags: *mut libc::c_int, keepTag: libc::c_int);
}
extern "C" {
    pub fn IV_filterPurge(iv: *mut IV, tags: *mut libc::c_int, purgeTag: libc::c_int);
}
extern "C" {
    pub fn IV_first(iv: *mut IV) -> *mut libc::c_int;
}
extern "C" {
    pub fn IV_next(iv: *mut IV, pi: *mut libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn IV_fill(iv: *mut IV, value: libc::c_int);
}
extern "C" {
    pub fn IV_copy(iv1: *mut IV, iv2: *mut IV);
}
extern "C" {
    pub fn IV_increment(iv: *mut IV, loc: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IV_decrement(iv: *mut IV, loc: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IV_findValue(iv: *mut IV, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IV_findValueAscending(iv: *mut IV, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IV_findValueDescending(iv: *mut IV, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn IV_inverseMap(listIV: *mut IV) -> *mut IV;
}
extern "C" {
    pub fn IV_targetEntries(listIV: *mut IV, target: libc::c_int) -> *mut IV;
}
extern "C" {
    pub fn IV_readFromFile(iv: *mut IV, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn IV_readFromFormattedFile(iv: *mut IV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IV_readFromBinaryFile(iv: *mut IV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IV_writeToFile(iv: *mut IV, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn IV_writeToFormattedFile(iv: *mut IV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IV_writeToBinaryFile(iv: *mut IV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IV_writeForHumanEye(iv: *mut IV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IV_writeStats(iv: *mut IV, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IV_fp80(
        iv: *mut IV,
        fp: *mut FILE,
        column: libc::c_int,
        pierr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IV_writeForMatlab(iv: *mut IV, name: *mut libc::c_char, fp: *mut FILE) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _A2 {
    pub type_: libc::c_int,
    pub n1: libc::c_int,
    pub n2: libc::c_int,
    pub inc1: libc::c_int,
    pub inc2: libc::c_int,
    pub nowned: libc::c_int,
    pub entries: *mut f64,
}
#[test]
fn bindgen_test_layout__A2() {
    assert_eq!(
        ::std::mem::size_of::<_A2>(),
        32usize,
        concat!("Size of: ", stringify!(_A2))
    );
    assert_eq!(
        ::std::mem::align_of::<_A2>(),
        8usize,
        concat!("Alignment of ", stringify!(_A2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_A2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).n1 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_A2), "::", stringify!(n1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).n2 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_A2), "::", stringify!(n2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).inc1 as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(_A2), "::", stringify!(inc1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).inc2 as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_A2), "::", stringify!(inc2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).nowned as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_A2),
            "::",
            stringify!(nowned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_A2>())).entries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_A2),
            "::",
            stringify!(entries)
        )
    );
}
pub type A2 = _A2;
extern "C" {
    pub fn A2_new() -> *mut A2;
}
extern "C" {
    pub fn A2_setDefaultFields(mtx: *mut A2);
}
extern "C" {
    pub fn A2_clearData(mtx: *mut A2);
}
extern "C" {
    pub fn A2_free(mtx: *mut A2);
}
extern "C" {
    pub fn A2_nrow(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_ncol(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_inc1(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_inc2(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_entries(mtx: *mut A2) -> *mut f64;
}
extern "C" {
    pub fn A2_row(mtx: *mut A2, irow: libc::c_int) -> *mut f64;
}
extern "C" {
    pub fn A2_column(mtx: *mut A2, jcol: libc::c_int) -> *mut f64;
}
extern "C" {
    pub fn A2_realEntry(mtx: *mut A2, irow: libc::c_int, jcol: libc::c_int, pValue: *mut f64);
}
extern "C" {
    pub fn A2_complexEntry(
        mtx: *mut A2,
        irow: libc::c_int,
        jcol: libc::c_int,
        pReal: *mut f64,
        pImag: *mut f64,
    );
}
extern "C" {
    pub fn A2_setRealEntry(mtx: *mut A2, irow: libc::c_int, jcol: libc::c_int, value: f64);
}
extern "C" {
    pub fn A2_setComplexEntry(
        mtx: *mut A2,
        irow: libc::c_int,
        jcol: libc::c_int,
        real: f64,
        imag: f64,
    );
}
extern "C" {
    pub fn A2_pointerToRealEntry(
        mtx: *mut A2,
        irow: libc::c_int,
        jcol: libc::c_int,
        ppValue: *mut *mut f64,
    );
}
extern "C" {
    pub fn A2_pointerToComplexEntry(
        mtx: *mut A2,
        irow: libc::c_int,
        jcol: libc::c_int,
        ppReal: *mut *mut f64,
        ppImag: *mut *mut f64,
    );
}
extern "C" {
    pub fn A2_init(
        mtx: *mut A2,
        type_: libc::c_int,
        n1: libc::c_int,
        n2: libc::c_int,
        inc1: libc::c_int,
        inc2: libc::c_int,
        entries: *mut f64,
    );
}
extern "C" {
    pub fn A2_subA2(
        mtxA: *mut A2,
        mtxB: *mut A2,
        firstrow: libc::c_int,
        lastrow: libc::c_int,
        firstcol: libc::c_int,
        lastcol: libc::c_int,
    );
}
extern "C" {
    pub fn A2_maxabs(a: *mut A2) -> f64;
}
extern "C" {
    pub fn A2_frobNorm(mtx: *mut A2) -> f64;
}
extern "C" {
    pub fn A2_oneNorm(mtx: *mut A2) -> f64;
}
extern "C" {
    pub fn A2_infinityNorm(mtx: *mut A2) -> f64;
}
extern "C" {
    pub fn A2_oneNormOfColumn(mtx: *mut A2, jcol: libc::c_int) -> f64;
}
extern "C" {
    pub fn A2_twoNormOfColumn(mtx: *mut A2, jcol: libc::c_int) -> f64;
}
extern "C" {
    pub fn A2_infinityNormOfColumn(mtx: *mut A2, jcol: libc::c_int) -> f64;
}
extern "C" {
    pub fn A2_oneNormOfRow(mtx: *mut A2, irow: libc::c_int) -> f64;
}
extern "C" {
    pub fn A2_twoNormOfRow(mtx: *mut A2, irow: libc::c_int) -> f64;
}
extern "C" {
    pub fn A2_infinityNormOfRow(mtx: *mut A2, irow: libc::c_int) -> f64;
}
extern "C" {
    pub fn A2_permuteRows(mtx: *mut A2, nrow: libc::c_int, index: *mut libc::c_int);
}
extern "C" {
    pub fn A2_permuteColumns(mtx: *mut A2, ncol: libc::c_int, index: *mut libc::c_int);
}
extern "C" {
    pub fn A2_sortRowsUp(mtx: *mut A2, nrow: libc::c_int, rowids: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn A2_sortColumnsUp(
        mtx: *mut A2,
        ncol: libc::c_int,
        colids: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn A2_QRreduce(
        mtxA: *mut A2,
        workDV: *mut DV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> f64;
}
extern "C" {
    pub fn A2_computeQ(
        Q: *mut A2,
        A: *mut A2,
        workDV: *mut DV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn A2_applyQT(
        Y: *mut A2,
        A: *mut A2,
        X: *mut A2,
        workDV: *mut DV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn A2_copyEntriesToVector(
        mtx: *mut A2,
        length: libc::c_int,
        dvec: *mut f64,
        copyflag: libc::c_int,
        storeflag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn A2_makeStaircase(mtxA: *mut A2);
}
extern "C" {
    pub fn A2_sizeOf(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_shiftBase(mtx: *mut A2, rowoff: libc::c_int, coloff: libc::c_int);
}
extern "C" {
    pub fn A2_rowMajor(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_columnMajor(mtx: *mut A2) -> libc::c_int;
}
extern "C" {
    pub fn A2_transpose(mtx: *mut A2);
}
extern "C" {
    pub fn A2_extractRow(mtx: *mut A2, row: *mut f64, irow: libc::c_int);
}
extern "C" {
    pub fn A2_extractColumn(mtx: *mut A2, col: *mut f64, jcol: libc::c_int);
}
extern "C" {
    pub fn A2_setRow(mtx: *mut A2, row: *mut f64, irow: libc::c_int);
}
extern "C" {
    pub fn A2_setColumn(mtx: *mut A2, col: *mut f64, jcol: libc::c_int);
}
extern "C" {
    pub fn A2_extractRowDV(mtx: *mut A2, rowDV: *mut DV, irow: libc::c_int);
}
extern "C" {
    pub fn A2_extractRowZV(mtx: *mut A2, rowZV: *mut ZV, irow: libc::c_int);
}
extern "C" {
    pub fn A2_extractColumnDV(mtx: *mut A2, colDV: *mut DV, jcol: libc::c_int);
}
extern "C" {
    pub fn A2_extractColumnZV(mtx: *mut A2, colZV: *mut ZV, jcol: libc::c_int);
}
extern "C" {
    pub fn A2_setRowDV(mtx: *mut A2, rowDV: *mut DV, irow: libc::c_int);
}
extern "C" {
    pub fn A2_setRowZV(mtx: *mut A2, rowZV: *mut ZV, irow: libc::c_int);
}
extern "C" {
    pub fn A2_setColumnDV(mtx: *mut A2, colDV: *mut DV, jcol: libc::c_int);
}
extern "C" {
    pub fn A2_setColumnZV(mtx: *mut A2, colZV: *mut ZV, jcol: libc::c_int);
}
extern "C" {
    pub fn A2_fillRandomUniform(a: *mut A2, lower: f64, upper: f64, seed: libc::c_int);
}
extern "C" {
    pub fn A2_fillRandomNormal(a: *mut A2, mean: f64, variance: f64, seed: libc::c_int);
}
extern "C" {
    pub fn A2_fillWithIdentity(a: *mut A2);
}
extern "C" {
    pub fn A2_zero(a: *mut A2);
}
extern "C" {
    pub fn A2_copy(A: *mut A2, B: *mut A2);
}
extern "C" {
    pub fn A2_sub(A: *mut A2, B: *mut A2);
}
extern "C" {
    pub fn A2_swapRows(a: *mut A2, irow1: libc::c_int, irow2: libc::c_int);
}
extern "C" {
    pub fn A2_swapColumns(a: *mut A2, jcol1: libc::c_int, jcol2: libc::c_int);
}
extern "C" {
    pub fn A2_readFromFile(mtx: *mut A2, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn A2_readFromFormattedFile(mtx: *mut A2, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn A2_readFromBinaryFile(mtx: *mut A2, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn A2_writeToFile(mtx: *mut A2, fn_: *mut libc::c_char);
}
extern "C" {
    pub fn A2_writeToFormattedFile(mtx: *mut A2, fp: *mut FILE);
}
extern "C" {
    pub fn A2_writeToBinaryFile(mtx: *mut A2, fp: *mut FILE);
}
extern "C" {
    pub fn A2_writeForHumanEye(mtx: *mut A2, fp: *mut FILE);
}
extern "C" {
    pub fn A2_writeStats(mtx: *mut A2, fp: *mut FILE);
}
extern "C" {
    pub fn A2_writeForMatlab(mtx: *mut A2, mtxname: *mut libc::c_char, fp: *mut FILE);
}
pub type DenseMtx = _DenseMtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DenseMtx {
    pub type_: libc::c_int,
    pub rowid: libc::c_int,
    pub colid: libc::c_int,
    pub nrow: libc::c_int,
    pub ncol: libc::c_int,
    pub inc1: libc::c_int,
    pub inc2: libc::c_int,
    pub rowind: *mut libc::c_int,
    pub colind: *mut libc::c_int,
    pub entries: *mut f64,
    pub wrkDV: DV,
    pub next: *mut DenseMtx,
}
#[test]
fn bindgen_test_layout__DenseMtx() {
    assert_eq!(
        ::std::mem::size_of::<_DenseMtx>(),
        88usize,
        concat!("Size of: ", stringify!(_DenseMtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_DenseMtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_DenseMtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).rowid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(rowid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).colid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(colid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).nrow as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(nrow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).ncol as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(ncol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).inc1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(inc1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).inc2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(inc2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).rowind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(rowind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).colind as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(colind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).entries as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).wrkDV as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(wrkDV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DenseMtx>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DenseMtx),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn DenseMtx_new() -> *mut DenseMtx;
}
extern "C" {
    pub fn DenseMtx_setDefaultFields(mtx: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_clearData(mtx: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_free(mtx: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_rowid(mtx: *mut DenseMtx) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_colid(mtx: *mut DenseMtx) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_dimensions(
        mtx: *mut DenseMtx,
        pnrow: *mut libc::c_int,
        pncol: *mut libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_rowIncrement(mtx: *mut DenseMtx) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_columnIncrement(mtx: *mut DenseMtx) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_rowIndices(
        mtx: *mut DenseMtx,
        pnrow: *mut libc::c_int,
        prowind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_columnIndices(
        mtx: *mut DenseMtx,
        pncol: *mut libc::c_int,
        pcolind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_entries(mtx: *mut DenseMtx) -> *mut f64;
}
extern "C" {
    pub fn DenseMtx_workspace(mtx: *mut DenseMtx) -> *mut libc::c_void;
}
extern "C" {
    pub fn DenseMtx_realEntry(
        mtx: *mut DenseMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        pValue: *mut f64,
    );
}
extern "C" {
    pub fn DenseMtx_complexEntry(
        mtx: *mut DenseMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        pReal: *mut f64,
        pImag: *mut f64,
    );
}
extern "C" {
    pub fn DenseMtx_setRealEntry(
        mtx: *mut DenseMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        value: f64,
    );
}
extern "C" {
    pub fn DenseMtx_setComplexEntry(
        mtx: *mut DenseMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        real: f64,
        imag: f64,
    );
}
extern "C" {
    pub fn DenseMtx_row(
        mtx: *mut DenseMtx,
        irow: libc::c_int,
        prowent: *mut *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_column(
        mtx: *mut DenseMtx,
        jcol: libc::c_int,
        pcolent: *mut *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_nbytesNeeded(
        type_: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_nbytesInWorkspace(mtx: *mut DenseMtx) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_setNbytesInWorkspace(mtx: *mut DenseMtx, nbytes: libc::c_int);
}
extern "C" {
    pub fn DenseMtx_setFields(
        mtx: *mut DenseMtx,
        type_: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        inc1: libc::c_int,
        inc2: libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_init(
        mtx: *mut DenseMtx,
        type_: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        inc1: libc::c_int,
        inc2: libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_initFromBuffer(mtx: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_initWithPointers(
        mtx: *mut DenseMtx,
        type_: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        inc1: libc::c_int,
        inc2: libc::c_int,
        rowind: *mut libc::c_int,
        colind: *mut libc::c_int,
        entries: *mut f64,
    );
}
extern "C" {
    pub fn DenseMtx_setA2(mtx: *mut DenseMtx, a2: *mut A2);
}
extern "C" {
    pub fn DenseMtx_initAsSubmatrix(
        B: *mut DenseMtx,
        A: *mut DenseMtx,
        firstrow: libc::c_int,
        lastrow: libc::c_int,
        firstcol: libc::c_int,
        lastcol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_readFromFile(mtx: *mut DenseMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_readFromFormattedFile(mtx: *mut DenseMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_readFromBinaryFile(mtx: *mut DenseMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_writeToFile(mtx: *mut DenseMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_writeToFormattedFile(mtx: *mut DenseMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_writeToBinaryFile(mtx: *mut DenseMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_writeStats(mtx: *mut DenseMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_writeForHumanEye(mtx: *mut DenseMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_writeForMatlab(
        mtx: *mut DenseMtx,
        mtxname: *mut libc::c_char,
        fp: *mut FILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn DenseMtx_permuteRows(mtx: *mut DenseMtx, oldToNewIV: *mut IV);
}
extern "C" {
    pub fn DenseMtx_permuteColumns(mtx: *mut DenseMtx, oldToNewIV: *mut IV);
}
extern "C" {
    pub fn DenseMtx_sort(mtx: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_copyRow(
        mtxB: *mut DenseMtx,
        irowB: libc::c_int,
        mtxA: *mut DenseMtx,
        irowA: libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_copyRowAndIndex(
        mtxB: *mut DenseMtx,
        irowB: libc::c_int,
        mtxA: *mut DenseMtx,
        irowA: libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_addRow(
        mtxB: *mut DenseMtx,
        irowB: libc::c_int,
        mtxA: *mut DenseMtx,
        irowA: libc::c_int,
    );
}
extern "C" {
    pub fn DenseMtx_zero(mtx: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_fillRandomEntries(mtx: *mut DenseMtx, drand: *mut Drand);
}
extern "C" {
    pub fn DenseMtx_checksums(mtx: *mut DenseMtx, sums: *mut f64);
}
extern "C" {
    pub fn DenseMtx_maxabs(mtx: *mut DenseMtx) -> f64;
}
extern "C" {
    pub fn DenseMtx_sub(mtxB: *mut DenseMtx, mtxA: *mut DenseMtx);
}
extern "C" {
    pub fn DenseMtx_copyRowIntoVector(mtx: *mut DenseMtx, irow: libc::c_int, vec: *mut f64);
}
extern "C" {
    pub fn DenseMtx_copyVectorIntoRow(mtx: *mut DenseMtx, irow: libc::c_int, vec: *mut f64);
}
extern "C" {
    pub fn DenseMtx_addVectorIntoRow(mtx: *mut DenseMtx, irow: libc::c_int, vec: *mut f64);
}
extern "C" {
    pub fn DenseMtx_scale(A: *mut DenseMtx, alpha: *mut f64) -> libc::c_int;
}
pub type IVL = _IVL;
pub type Ichunk = _Ichunk;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IVL {
    pub type_: libc::c_int,
    pub maxnlist: libc::c_int,
    pub nlist: libc::c_int,
    pub tsize: libc::c_int,
    pub sizes: *mut libc::c_int,
    pub p_vec: *mut *mut libc::c_int,
    pub incr: libc::c_int,
    pub chunk: *mut Ichunk,
}
#[test]
fn bindgen_test_layout__IVL() {
    assert_eq!(
        ::std::mem::size_of::<_IVL>(),
        48usize,
        concat!("Size of: ", stringify!(_IVL))
    );
    assert_eq!(
        ::std::mem::align_of::<_IVL>(),
        8usize,
        concat!("Alignment of ", stringify!(_IVL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).maxnlist as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(maxnlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).nlist as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).tsize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(tsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).sizes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).p_vec as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(p_vec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).incr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IVL>())).chunk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IVL),
            "::",
            stringify!(chunk)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Ichunk {
    pub size: libc::c_int,
    pub inuse: libc::c_int,
    pub base: *mut libc::c_int,
    pub next: *mut Ichunk,
}
#[test]
fn bindgen_test_layout__Ichunk() {
    assert_eq!(
        ::std::mem::size_of::<_Ichunk>(),
        24usize,
        concat!("Size of: ", stringify!(_Ichunk))
    );
    assert_eq!(
        ::std::mem::align_of::<_Ichunk>(),
        8usize,
        concat!("Alignment of ", stringify!(_Ichunk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ichunk>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ichunk),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ichunk>())).inuse as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ichunk),
            "::",
            stringify!(inuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ichunk>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ichunk),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ichunk>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ichunk),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn IVL_new() -> *mut IVL;
}
extern "C" {
    pub fn IVL_setDefaultFields(ivl: *mut IVL);
}
extern "C" {
    pub fn IVL_clearData(ivl: *mut IVL);
}
extern "C" {
    pub fn IVL_free(ivl: *mut IVL) -> *mut IVL;
}
extern "C" {
    pub fn IVL_type(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_maxnlist(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_nlist(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_tsize(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_incr(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_setincr(ivl: *mut IVL, incr: libc::c_int);
}
extern "C" {
    pub fn IVL_init1(ivl: *mut IVL, type_: libc::c_int, maxnlist: libc::c_int);
}
extern "C" {
    pub fn IVL_init2(ivl: *mut IVL, type_: libc::c_int, maxnlist: libc::c_int, tsize: libc::c_int);
}
extern "C" {
    pub fn IVL_init3(
        ivl: *mut IVL,
        type_: libc::c_int,
        maxnlist: libc::c_int,
        sizes: *mut libc::c_int,
    );
}
extern "C" {
    pub fn IVL_setMaxnlist(ivl: *mut IVL, newmaxnlist: libc::c_int);
}
extern "C" {
    pub fn IVL_setNlist(ivl: *mut IVL, newnlist: libc::c_int);
}
extern "C" {
    pub fn IVL_initFromSubIVL(
        subIVL: *mut IVL,
        ivl: *mut IVL,
        keeplistIV: *mut IV,
        keepentriesIV: *mut IV,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IVL_listAndSize(
        ivl: *mut IVL,
        ilist: libc::c_int,
        psize: *mut libc::c_int,
        pivec: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn IVL_firstInList(ivl: *mut IVL, ilist: libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn IVL_nextInList(
        ivl: *mut IVL,
        ilist: libc::c_int,
        pi: *mut libc::c_int,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn IVL_setList(
        ivl: *mut IVL,
        ilist: libc::c_int,
        isize_: libc::c_int,
        ivec: *mut libc::c_int,
    );
}
extern "C" {
    pub fn IVL_setPointerToList(
        ivl: *mut IVL,
        ilist: libc::c_int,
        isize_: libc::c_int,
        ivec: *mut libc::c_int,
    );
}
extern "C" {
    pub fn IVL_make9P(n1: libc::c_int, n2: libc::c_int, ncomp: libc::c_int) -> *mut IVL;
}
extern "C" {
    pub fn IVL_make27P(
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        ncomp: libc::c_int,
    ) -> *mut IVL;
}
extern "C" {
    pub fn IVL_make13P(n1: libc::c_int, n2: libc::c_int) -> *mut IVL;
}
extern "C" {
    pub fn IVL_make5P(n1: libc::c_int, n2: libc::c_int) -> *mut IVL;
}
extern "C" {
    pub fn IVL_sizeOf(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_min(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_max(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_maxListSize(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_sum(ivl: *mut IVL) -> libc::c_int;
}
extern "C" {
    pub fn IVL_sortUp(ivl: *mut IVL);
}
extern "C" {
    pub fn IVL_equivMap1(ivl: *mut IVL) -> *mut libc::c_int;
}
extern "C" {
    pub fn IVL_equivMap2(ivl: *mut IVL) -> *mut IV;
}
extern "C" {
    pub fn IVL_overwrite(ivl: *mut IVL, oldToNewIV: *mut IV);
}
extern "C" {
    pub fn IVL_mapEntries(ivl: *mut IVL, mapIV: *mut IV) -> *mut IVL;
}
extern "C" {
    pub fn IVL_absorbIVL(ivl1: *mut IVL, ivl2: *mut IVL, mapIV: *mut IV);
}
extern "C" {
    pub fn IVL_expand(ivl: *mut IVL, eqmapIV: *mut IV) -> *mut IVL;
}
extern "C" {
    pub fn IVL_readFromFile(ivl: *mut IVL, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn IVL_readFromFormattedFile(ivl: *mut IVL, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IVL_readFromBinaryFile(ivl: *mut IVL, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IVL_writeToFile(ivl: *mut IVL, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn IVL_writeToFormattedFile(ivl: *mut IVL, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IVL_writeToBinaryFile(ivl: *mut IVL, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IVL_writeForHumanEye(ivl: *mut IVL, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn IVL_writeStats(ivl: *mut IVL, fp: *mut FILE) -> libc::c_int;
}
pub type InpMtx = _InpMtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _InpMtx {
    pub coordType: libc::c_int,
    pub storageMode: libc::c_int,
    pub inputMode: libc::c_int,
    pub maxnent: libc::c_int,
    pub nent: libc::c_int,
    pub resizeMultiple: f64,
    pub ivec1IV: IV,
    pub ivec2IV: IV,
    pub dvecDV: DV,
    pub maxnvector: libc::c_int,
    pub nvector: libc::c_int,
    pub vecidsIV: IV,
    pub sizesIV: IV,
    pub offsetsIV: IV,
}
#[test]
fn bindgen_test_layout__InpMtx() {
    assert_eq!(
        ::std::mem::size_of::<_InpMtx>(),
        184usize,
        concat!("Size of: ", stringify!(_InpMtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_InpMtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_InpMtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).coordType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(coordType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).storageMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(storageMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).inputMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(inputMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).maxnent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(maxnent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).nent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(nent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).resizeMultiple as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(resizeMultiple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).ivec1IV as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(ivec1IV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).ivec2IV as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(ivec2IV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).dvecDV as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(dvecDV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).maxnvector as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(maxnvector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).nvector as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(nvector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).vecidsIV as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(vecidsIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).sizesIV as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(sizesIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_InpMtx>())).offsetsIV as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_InpMtx),
            "::",
            stringify!(offsetsIV)
        )
    );
}
extern "C" {
    pub fn InpMtx_new() -> *mut InpMtx;
}
extern "C" {
    pub fn InpMtx_setDefaultFields(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_clearData(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_free(inpmtx: *mut InpMtx) -> *mut InpMtx;
}
extern "C" {
    pub fn InpMtx_coordType(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_storageMode(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_inputMode(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_maxnent(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nent(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_maxnvector(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nvector(inpmtx: *mut InpMtx) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_resizeMultiple(inpmtx: *mut InpMtx) -> f64;
}
extern "C" {
    pub fn InpMtx_ivec1(inpmtx: *mut InpMtx) -> *mut libc::c_int;
}
extern "C" {
    pub fn InpMtx_ivec2(inpmtx: *mut InpMtx) -> *mut libc::c_int;
}
extern "C" {
    pub fn InpMtx_dvec(inpmtx: *mut InpMtx) -> *mut f64;
}
extern "C" {
    pub fn InpMtx_sizes(inpmtx: *mut InpMtx) -> *mut libc::c_int;
}
extern "C" {
    pub fn InpMtx_vecids(inpmtx: *mut InpMtx) -> *mut libc::c_int;
}
extern "C" {
    pub fn InpMtx_offsets(inpmtx: *mut InpMtx) -> *mut libc::c_int;
}
extern "C" {
    pub fn InpMtx_vector(
        inpmtx: *mut InpMtx,
        id: libc::c_int,
        pnent: *mut libc::c_int,
        pindices: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_realVector(
        inpmtx: *mut InpMtx,
        id: libc::c_int,
        pnent: *mut libc::c_int,
        pindices: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_complexVector(
        inpmtx: *mut InpMtx,
        id: libc::c_int,
        pnent: *mut libc::c_int,
        pindices: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_setMaxnent(inpmtx: *mut InpMtx, newmaxnent: libc::c_int);
}
extern "C" {
    pub fn InpMtx_setNent(inpmtx: *mut InpMtx, newnent: libc::c_int);
}
extern "C" {
    pub fn InpMtx_setMaxnvector(inpmtx: *mut InpMtx, newmaxnvector: libc::c_int);
}
extern "C" {
    pub fn InpMtx_setNvector(inpmtx: *mut InpMtx, newnvector: libc::c_int);
}
extern "C" {
    pub fn InpMtx_setResizeMultiple(inpmtx: *mut InpMtx, resizeMultiple: f64);
}
extern "C" {
    pub fn InpMtx_setCoordType(inpmtx: *mut InpMtx, type_: libc::c_int);
}
extern "C" {
    pub fn InpMtx_init(
        inpmtx: *mut InpMtx,
        coordType: libc::c_int,
        inputMode: libc::c_int,
        maxnent: libc::c_int,
        maxnvector: libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_changeCoordType(inpmtx: *mut InpMtx, newType: libc::c_int);
}
extern "C" {
    pub fn InpMtx_changeStorageMode(inpmtx: *mut InpMtx, newMode: libc::c_int);
}
extern "C" {
    pub fn InpMtx_inputEntry(inpmtx: *mut InpMtx, row: libc::c_int, col: libc::c_int);
}
extern "C" {
    pub fn InpMtx_inputRealEntry(
        inpmtx: *mut InpMtx,
        row: libc::c_int,
        col: libc::c_int,
        value: f64,
    );
}
extern "C" {
    pub fn InpMtx_inputComplexEntry(
        inpmtx: *mut InpMtx,
        row: libc::c_int,
        col: libc::c_int,
        real: f64,
        imag: f64,
    );
}
extern "C" {
    pub fn InpMtx_inputRow(
        inpmtx: *mut InpMtx,
        row: libc::c_int,
        rowsize: libc::c_int,
        rowind: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_inputRealRow(
        inpmtx: *mut InpMtx,
        row: libc::c_int,
        rowsize: libc::c_int,
        rowind: *mut libc::c_int,
        rowent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputComplexRow(
        inpmtx: *mut InpMtx,
        row: libc::c_int,
        rowsize: libc::c_int,
        rowind: *mut libc::c_int,
        rowent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputColumn(
        inpmtx: *mut InpMtx,
        col: libc::c_int,
        colsize: libc::c_int,
        colind: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_inputRealColumn(
        inpmtx: *mut InpMtx,
        col: libc::c_int,
        colsize: libc::c_int,
        colind: *mut libc::c_int,
        colent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputComplexColumn(
        inpmtx: *mut InpMtx,
        col: libc::c_int,
        colsize: libc::c_int,
        colind: *mut libc::c_int,
        colent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputChevron(
        inpmtx: *mut InpMtx,
        chv: libc::c_int,
        chvsize: libc::c_int,
        chvind: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_inputRealChevron(
        inpmtx: *mut InpMtx,
        chv: libc::c_int,
        chvsize: libc::c_int,
        chvind: *mut libc::c_int,
        chvent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputComplexChevron(
        inpmtx: *mut InpMtx,
        chv: libc::c_int,
        chvsize: libc::c_int,
        chvind: *mut libc::c_int,
        chvent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputMatrix(
        inpmtx: *mut InpMtx,
        nrow: libc::c_int,
        ncol: libc::c_int,
        rowstride: libc::c_int,
        colstride: libc::c_int,
        rowind: *mut libc::c_int,
        colind: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_inputRealMatrix(
        inpmtx: *mut InpMtx,
        nrow: libc::c_int,
        ncol: libc::c_int,
        rowstride: libc::c_int,
        colstride: libc::c_int,
        rowind: *mut libc::c_int,
        colind: *mut libc::c_int,
        mtxent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputComplexMatrix(
        inpmtx: *mut InpMtx,
        nrow: libc::c_int,
        ncol: libc::c_int,
        rowstride: libc::c_int,
        colstride: libc::c_int,
        rowind: *mut libc::c_int,
        colind: *mut libc::c_int,
        mtxent: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputTriples(
        inpmtx: *mut InpMtx,
        ntriples: libc::c_int,
        rowids: *mut libc::c_int,
        colids: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_inputRealTriples(
        inpmtx: *mut InpMtx,
        ntriples: libc::c_int,
        rowids: *mut libc::c_int,
        colids: *mut libc::c_int,
        entries: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_inputComplexTriples(
        inpmtx: *mut InpMtx,
        ntriples: libc::c_int,
        rowids: *mut libc::c_int,
        colids: *mut libc::c_int,
        entries: *mut f64,
    );
}
extern "C" {
    pub fn InpMtx_permute(
        inpmtx: *mut InpMtx,
        rowOldToNew: *mut libc::c_int,
        colOldToNew: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_initFromSubmatrix(
        B: *mut InpMtx,
        A: *mut InpMtx,
        BrowsIV: *mut IV,
        BcolsIV: *mut IV,
        symmetryflag: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_sortAndCompress(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_convertToVectors(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_dropOffdiagonalEntries(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_dropLowerTriangle(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_dropUpperTriangle(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_mapToLowerTriangle(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_mapToUpperTriangle(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_mapToUpperTriangleH(inpmtx: *mut InpMtx);
}
extern "C" {
    pub fn InpMtx_checksums(inpmtx: *mut InpMtx, sums: *mut f64);
}
extern "C" {
    pub fn InpMtx_randomMatrix(
        mtx: *mut InpMtx,
        inputMode: libc::c_int,
        coordType: libc::c_int,
        storageMode: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        symflag: libc::c_int,
        nonzerodiag: libc::c_int,
        nitem: libc::c_int,
        seed: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_range(
        mtx: *mut InpMtx,
        pmincol: *mut libc::c_int,
        pmaxcol: *mut libc::c_int,
        pminrow: *mut libc::c_int,
        pmaxrow: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_fullAdjacency(inpmtx: *mut InpMtx) -> *mut IVL;
}
extern "C" {
    pub fn InpMtx_fullAdjacency2(inpmtxA: *mut InpMtx, inpmtxB: *mut InpMtx) -> *mut IVL;
}
extern "C" {
    pub fn InpMtx_adjForATA(inpmtxA: *mut InpMtx) -> *mut IVL;
}
extern "C" {
    pub fn InpMtx_log10profile(
        inpmtx: *mut InpMtx,
        npts: libc::c_int,
        xDV: *mut DV,
        yDV: *mut DV,
        tausmall: f64,
        taubig: f64,
        pnzero: *mut libc::c_int,
        pnsmall: *mut libc::c_int,
        pnbig: *mut libc::c_int,
    );
}
extern "C" {
    pub fn InpMtx_nonsym_gmmm(
        A: *mut InpMtx,
        beta: *mut f64,
        Y: *mut DenseMtx,
        alpha: *mut f64,
        X: *mut DenseMtx,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nonsym_gmmm_T(
        A: *mut InpMtx,
        beta: *mut f64,
        Y: *mut DenseMtx,
        alpha: *mut f64,
        X: *mut DenseMtx,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nonsym_gmmm_H(
        A: *mut InpMtx,
        beta: *mut f64,
        Y: *mut DenseMtx,
        alpha: *mut f64,
        X: *mut DenseMtx,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_sym_gmmm(
        A: *mut InpMtx,
        beta: *mut f64,
        Y: *mut DenseMtx,
        alpha: *mut f64,
        X: *mut DenseMtx,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_herm_gmmm(
        A: *mut InpMtx,
        beta: *mut f64,
        Y: *mut DenseMtx,
        alpha: *mut f64,
        X: *mut DenseMtx,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nonsym_gmvm(
        A: *mut InpMtx,
        beta: *mut f64,
        ny: libc::c_int,
        y: *mut f64,
        alpha: *mut f64,
        nx: libc::c_int,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nonsym_gmvm_T(
        A: *mut InpMtx,
        beta: *mut f64,
        ny: libc::c_int,
        y: *mut f64,
        alpha: *mut f64,
        nx: libc::c_int,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nonsym_gmvm_H(
        A: *mut InpMtx,
        beta: *mut f64,
        ny: libc::c_int,
        y: *mut f64,
        alpha: *mut f64,
        nx: libc::c_int,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_sym_gmvm(
        A: *mut InpMtx,
        beta: *mut f64,
        ny: libc::c_int,
        y: *mut f64,
        alpha: *mut f64,
        nx: libc::c_int,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_herm_gmvm(
        A: *mut InpMtx,
        beta: *mut f64,
        ny: libc::c_int,
        y: *mut f64,
        alpha: *mut f64,
        nx: libc::c_int,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_nonsym_mmm(A: *mut InpMtx, Y: *mut DenseMtx, alpha: *mut f64, X: *mut DenseMtx);
}
extern "C" {
    pub fn InpMtx_nonsym_mmm_T(A: *mut InpMtx, Y: *mut DenseMtx, alpha: *mut f64, X: *mut DenseMtx);
}
extern "C" {
    pub fn InpMtx_nonsym_mmm_H(A: *mut InpMtx, Y: *mut DenseMtx, alpha: *mut f64, X: *mut DenseMtx);
}
extern "C" {
    pub fn InpMtx_sym_mmm(A: *mut InpMtx, Y: *mut DenseMtx, alpha: *mut f64, X: *mut DenseMtx);
}
extern "C" {
    pub fn InpMtx_herm_mmm(A: *mut InpMtx, Y: *mut DenseMtx, alpha: *mut f64, X: *mut DenseMtx);
}
extern "C" {
    pub fn InpMtx_nonsym_mmmVector(A: *mut InpMtx, y: *mut f64, alpha: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn InpMtx_nonsym_mmmVector_T(A: *mut InpMtx, y: *mut f64, alpha: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn InpMtx_nonsym_mmmVector_H(A: *mut InpMtx, y: *mut f64, alpha: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn InpMtx_sym_mmmVector(A: *mut InpMtx, y: *mut f64, alpha: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn InpMtx_herm_mmmVector(A: *mut InpMtx, y: *mut f64, alpha: *mut f64, x: *mut f64);
}
extern "C" {
    pub fn InpMtx_supportNonsym(A: *mut InpMtx, rowsupIV: *mut IV, colsupIV: *mut IV);
}
extern "C" {
    pub fn InpMtx_supportNonsymT(A: *mut InpMtx, rowsupIV: *mut IV, colsupIV: *mut IV);
}
extern "C" {
    pub fn InpMtx_supportNonsymH(A: *mut InpMtx, rowsupIV: *mut IV, colsupIV: *mut IV);
}
extern "C" {
    pub fn InpMtx_supportSym(A: *mut InpMtx, supIV: *mut IV);
}
extern "C" {
    pub fn InpMtx_supportHerm(A: *mut InpMtx, supIV: *mut IV);
}
extern "C" {
    pub fn InpMtx_mapEntries(inpmtx: *mut InpMtx, rowmapIV: *mut IV, colmapIV: *mut IV);
}
extern "C" {
    pub fn InpMtx_readFromFile(inpmtx: *mut InpMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_readFromFormattedFile(inpmtx: *mut InpMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_readFromBinaryFile(inpmtx: *mut InpMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_writeToFile(inpmtx: *mut InpMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_writeToFormattedFile(inpmtx: *mut InpMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_writeToBinaryFile(inpmtx: *mut InpMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_writeForHumanEye(inpmtx: *mut InpMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_writeStats(inpmtx: *mut InpMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_writeForMatlab(
        inpmtx: *mut InpMtx,
        mtxname: *mut libc::c_char,
        fp: *mut FILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn InpMtx_readFromHBfile(inpmtx: *mut InpMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
pub type Graph = _Graph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Graph {
    pub type_: libc::c_int,
    pub nvtx: libc::c_int,
    pub nvbnd: libc::c_int,
    pub nedges: libc::c_int,
    pub totvwght: libc::c_int,
    pub totewght: libc::c_int,
    pub adjIVL: *mut IVL,
    pub vwghts: *mut libc::c_int,
    pub ewghtIVL: *mut IVL,
}
#[test]
fn bindgen_test_layout__Graph() {
    assert_eq!(
        ::std::mem::size_of::<_Graph>(),
        48usize,
        concat!("Size of: ", stringify!(_Graph))
    );
    assert_eq!(
        ::std::mem::align_of::<_Graph>(),
        8usize,
        concat!("Alignment of ", stringify!(_Graph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).nvtx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(nvtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).nvbnd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(nvbnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).nedges as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(nedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).totvwght as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(totvwght)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).totewght as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(totewght)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).adjIVL as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(adjIVL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).vwghts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(vwghts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Graph>())).ewghtIVL as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_Graph),
            "::",
            stringify!(ewghtIVL)
        )
    );
}
extern "C" {
    pub fn Graph_new() -> *mut Graph;
}
extern "C" {
    pub fn Graph_setDefaultFields(g: *mut Graph);
}
extern "C" {
    pub fn Graph_clearData(g: *mut Graph);
}
extern "C" {
    pub fn Graph_free(g: *mut Graph);
}
extern "C" {
    pub fn Graph_compress(
        g: *mut Graph,
        cmap: *mut libc::c_int,
        coarseType: libc::c_int,
    ) -> *mut Graph;
}
extern "C" {
    pub fn Graph_compress2(g: *mut Graph, mapIV: *mut IV, coarseType: libc::c_int) -> *mut Graph;
}
extern "C" {
    pub fn Graph_equivMap(g: *mut Graph) -> *mut IV;
}
extern "C" {
    pub fn Graph_expand(g: *mut Graph, nvtxbig: libc::c_int, map: *mut libc::c_int) -> *mut Graph;
}
extern "C" {
    pub fn Graph_expand2(g: *mut Graph, mapIV: *mut IV) -> *mut Graph;
}
extern "C" {
    pub fn Graph_fillFromOffsets(
        g: *mut Graph,
        neqns: libc::c_int,
        offsets: *mut libc::c_int,
        adjncy: *mut libc::c_int,
        flag: libc::c_int,
    );
}
extern "C" {
    pub fn Graph_init1(
        g: *mut Graph,
        type_: libc::c_int,
        nvtx: libc::c_int,
        nvbnd: libc::c_int,
        nedges: libc::c_int,
        adjType: libc::c_int,
        ewghtType: libc::c_int,
    );
}
extern "C" {
    pub fn Graph_init2(
        g: *mut Graph,
        type_: libc::c_int,
        nvtx: libc::c_int,
        nvbnd: libc::c_int,
        nedges: libc::c_int,
        totvwght: libc::c_int,
        totewght: libc::c_int,
        adjIVL: *mut IVL,
        vwghts: *mut libc::c_int,
        ewghtIVL: *mut IVL,
    );
}
extern "C" {
    pub fn Graph_externalDegree(g: *mut Graph, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Graph_adjAndSize(
        g: *mut Graph,
        jvtx: libc::c_int,
        psize: *mut libc::c_int,
        padj: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn Graph_adjAndEweights(
        g: *mut Graph,
        jvtx: libc::c_int,
        psize: *mut libc::c_int,
        padj: *mut *mut libc::c_int,
        pewghts: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn Graph_sizeOf(g: *mut Graph) -> libc::c_int;
}
extern "C" {
    pub fn Graph_componentMap(g: *mut Graph) -> *mut IV;
}
extern "C" {
    pub fn Graph_componentStats(
        g: *mut Graph,
        map: *mut libc::c_int,
        counts: *mut libc::c_int,
        weights: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Graph_subGraph(
        g: *mut Graph,
        icomp: libc::c_int,
        compids: *mut libc::c_int,
        pmap: *mut *mut libc::c_int,
    ) -> *mut Graph;
}
extern "C" {
    pub fn Graph_isSymmetric(graph: *mut Graph) -> libc::c_int;
}
extern "C" {
    pub fn Graph_BFS(
        graph: *mut Graph,
        v: libc::c_int,
        levelsIV: *mut IV,
        listIV: *mut IV,
        parIV: *mut IV,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Graph_BFS2(
        graph: *mut Graph,
        seedsIV: *mut IV,
        levelsIV: *mut IV,
        listIV: *mut IV,
        parIV: *mut IV,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Graph_pseudodiameter(
        g: *mut Graph,
        root: libc::c_int,
        startLevelsIV: *mut IV,
        endLevelsIV: *mut IV,
        pstart: *mut libc::c_int,
        pend: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Graph_majorAxis(
        graph: *mut Graph,
        vstart: libc::c_int,
        vend: libc::c_int,
        startLevelsIV: *mut IV,
        endLevelsIV: *mut IV,
        tolerance: libc::c_int,
    ) -> *mut IV;
}
extern "C" {
    pub fn Graph_polarMoment(
        graph: *mut Graph,
        v: libc::c_int,
        levelsIV: *mut IV,
        listIV: *mut IV,
    ) -> f64;
}
extern "C" {
    pub fn Graph_setListsFromOffsets(
        g: *mut Graph,
        neqns: libc::c_int,
        offsets: *mut libc::c_int,
        adjncy: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Graph_wirebasketStages(graph: *mut Graph, stagesIV: *mut IV, radius: libc::c_int);
}
extern "C" {
    pub fn Graph_readFromFile(graph: *mut Graph, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Graph_readFromChacoFile(graph: *mut Graph, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Graph_readFromFormattedFile(graph: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_readFromBinaryFile(graph: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_writeToFile(graph: *mut Graph, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Graph_writeToFormattedFile(graph: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_writeToBinaryFile(graph: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_writeForHumanEye(graph: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_writeStats(graph: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_writeToMetisFile(g: *mut Graph, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Graph_getTree(
        graph: *mut Graph,
        par: *mut libc::c_int,
        mark: *mut libc::c_char,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn Graph_getTree2(
        graph: *mut Graph,
        nlevel: libc::c_int,
        par: *mut libc::c_int,
        mark: *mut libc::c_char,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
pub type Tree = _Tree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tree {
    pub n: libc::c_int,
    pub root: libc::c_int,
    pub par: *mut libc::c_int,
    pub fch: *mut libc::c_int,
    pub sib: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout__Tree() {
    assert_eq!(
        ::std::mem::size_of::<_Tree>(),
        32usize,
        concat!("Size of: ", stringify!(_Tree))
    );
    assert_eq!(
        ::std::mem::align_of::<_Tree>(),
        8usize,
        concat!("Alignment of ", stringify!(_Tree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Tree>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_Tree), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Tree>())).root as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Tree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Tree>())).par as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Tree),
            "::",
            stringify!(par)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Tree>())).fch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Tree),
            "::",
            stringify!(fch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Tree>())).sib as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Tree),
            "::",
            stringify!(sib)
        )
    );
}
extern "C" {
    pub fn Tree_new() -> *mut Tree;
}
extern "C" {
    pub fn Tree_setDefaultFields(tree: *mut Tree);
}
extern "C" {
    pub fn Tree_clearData(tree: *mut Tree);
}
extern "C" {
    pub fn Tree_free(tree: *mut Tree);
}
extern "C" {
    pub fn Tree_nnodes(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_root(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_par(tree: *mut Tree) -> *mut libc::c_int;
}
extern "C" {
    pub fn Tree_fch(tree: *mut Tree) -> *mut libc::c_int;
}
extern "C" {
    pub fn Tree_sib(tree: *mut Tree) -> *mut libc::c_int;
}
extern "C" {
    pub fn Tree_init1(tree: *mut Tree, size: libc::c_int);
}
extern "C" {
    pub fn Tree_init2(tree: *mut Tree, size: libc::c_int, par: *mut libc::c_int);
}
extern "C" {
    pub fn Tree_init3(
        tree: *mut Tree,
        size: libc::c_int,
        par: *mut libc::c_int,
        fch: *mut libc::c_int,
        sib: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Tree_setFchSibRoot(tree: *mut Tree);
}
extern "C" {
    pub fn Tree_setRoot(tree: *mut Tree);
}
extern "C" {
    pub fn Tree_maximizeGainIV(
        tree: *mut Tree,
        gainIV: *mut IV,
        ptotalgain: *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn Tree_initFromSubtree(
        subtree: *mut Tree,
        nodeidsIV: *mut IV,
        tree: *mut Tree,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Tree_postOTfirst(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_postOTnext(tree: *mut Tree, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Tree_preOTfirst(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_preOTnext(tree: *mut Tree, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Tree_nleaves(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_nroots(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_nchild(tree: *mut Tree, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Tree_nchildIV(tree: *mut Tree) -> *mut IV;
}
extern "C" {
    pub fn Tree_height(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_maxNchild(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_sizeOf(tree: *mut Tree) -> libc::c_int;
}
extern "C" {
    pub fn Tree_setSubtreeImetric(tree: *mut Tree, vmetricIV: *mut IV) -> *mut IV;
}
extern "C" {
    pub fn Tree_setSubtreeDmetric(tree: *mut Tree, vmetricDV: *mut DV) -> *mut DV;
}
extern "C" {
    pub fn Tree_setDepthImetric(tree: *mut Tree, vmetricIV: *mut IV) -> *mut IV;
}
extern "C" {
    pub fn Tree_setDepthDmetric(tree: *mut Tree, vmetricDV: *mut DV) -> *mut DV;
}
extern "C" {
    pub fn Tree_setHeightImetric(tree: *mut Tree, vmetricIV: *mut IV) -> *mut IV;
}
extern "C" {
    pub fn Tree_setHeightDmetric(tree: *mut Tree, vmetricDV: *mut DV) -> *mut DV;
}
extern "C" {
    pub fn Tree_leftJustify(tree: *mut Tree);
}
extern "C" {
    pub fn Tree_leftJustifyI(tree: *mut Tree, metricIV: *mut IV);
}
extern "C" {
    pub fn Tree_leftJustifyD(tree: *mut Tree, metricDV: *mut DV);
}
extern "C" {
    pub fn Tree_fillNewToOldPerm(tree: *mut Tree, newToOld: *mut libc::c_int);
}
extern "C" {
    pub fn Tree_fillOldToNewPerm(tree: *mut Tree, oldToNew: *mut libc::c_int);
}
extern "C" {
    pub fn Tree_fillBothPerms(
        tree: *mut Tree,
        newToOld: *mut libc::c_int,
        oldToNew: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Tree_readFromFile(tree: *mut Tree, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Tree_readFromFormattedFile(tree: *mut Tree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Tree_readFromBinaryFile(tree: *mut Tree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Tree_writeToFile(tree: *mut Tree, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Tree_writeToFormattedFile(tree: *mut Tree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Tree_writeToBinaryFile(tree: *mut Tree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Tree_writeForHumanEye(tree: *mut Tree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Tree_writeStats(tree: *mut Tree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Tree_fundChainMap(tree: *mut Tree) -> *mut IV;
}
extern "C" {
    pub fn Tree_compress(tree: *mut Tree, mapIV: *mut IV) -> *mut Tree;
}
extern "C" {
    pub fn Tree_permute(
        tree: *mut Tree,
        newToOld: *mut libc::c_int,
        oldToNew: *mut libc::c_int,
    ) -> *mut Tree;
}
extern "C" {
    pub fn Tree_setBoxesII(
        tree: *mut Tree,
        vmetric: *mut libc::c_int,
        tmetric: *mut libc::c_int,
        xmin: f64,
        xmax: f64,
        ymin: f64,
        ymax: f64,
        west: *mut f64,
        east: *mut f64,
        south: *mut f64,
        north: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Tree_setBoxesDD(
        tree: *mut Tree,
        vmetric: *mut f64,
        tmetric: *mut f64,
        xmin: f64,
        xmax: f64,
        ymin: f64,
        ymax: f64,
        west: *mut f64,
        east: *mut f64,
        south: *mut f64,
        north: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Tree_getSimpleCoords(
        tree: *mut Tree,
        heightflag: libc::c_char,
        coordflag: libc::c_char,
        xDV: *mut DV,
        yDV: *mut DV,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Tree_drawToEPS(
        tree: *mut Tree,
        filename: *mut libc::c_char,
        xDV: *mut DV,
        yDV: *mut DV,
        rscale: f64,
        radiusDV: *mut DV,
        labelflag: libc::c_int,
        fontscale: f64,
        labelsIV: *mut IV,
        bbox: *mut f64,
        frame: *mut f64,
        bounds: *mut f64,
    ) -> libc::c_int;
}
pub type ETree = _ETree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETree {
    pub nfront: libc::c_int,
    pub nvtx: libc::c_int,
    pub tree: *mut Tree,
    pub nodwghtsIV: *mut IV,
    pub bndwghtsIV: *mut IV,
    pub vtxToFrontIV: *mut IV,
}
#[test]
fn bindgen_test_layout__ETree() {
    assert_eq!(
        ::std::mem::size_of::<_ETree>(),
        40usize,
        concat!("Size of: ", stringify!(_ETree))
    );
    assert_eq!(
        ::std::mem::align_of::<_ETree>(),
        8usize,
        concat!("Alignment of ", stringify!(_ETree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ETree>())).nfront as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETree),
            "::",
            stringify!(nfront)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ETree>())).nvtx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETree),
            "::",
            stringify!(nvtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ETree>())).tree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETree),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ETree>())).nodwghtsIV as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETree),
            "::",
            stringify!(nodwghtsIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ETree>())).bndwghtsIV as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETree),
            "::",
            stringify!(bndwghtsIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ETree>())).vtxToFrontIV as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETree),
            "::",
            stringify!(vtxToFrontIV)
        )
    );
}
extern "C" {
    pub fn ETree_new() -> *mut ETree;
}
extern "C" {
    pub fn ETree_setDefaultFields(etree: *mut ETree);
}
extern "C" {
    pub fn ETree_clearData(etree: *mut ETree);
}
extern "C" {
    pub fn ETree_free(etree: *mut ETree);
}
extern "C" {
    pub fn ETree_nfront(etree: *mut ETree) -> libc::c_int;
}
extern "C" {
    pub fn ETree_nvtx(etree: *mut ETree) -> libc::c_int;
}
extern "C" {
    pub fn ETree_tree(etree: *mut ETree) -> *mut Tree;
}
extern "C" {
    pub fn ETree_root(etree: *mut ETree) -> libc::c_int;
}
extern "C" {
    pub fn ETree_par(etree: *mut ETree) -> *mut libc::c_int;
}
extern "C" {
    pub fn ETree_fch(etree: *mut ETree) -> *mut libc::c_int;
}
extern "C" {
    pub fn ETree_sib(etree: *mut ETree) -> *mut libc::c_int;
}
extern "C" {
    pub fn ETree_nodwghtsIV(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_nodwghts(etree: *mut ETree) -> *mut libc::c_int;
}
extern "C" {
    pub fn ETree_bndwghtsIV(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_bndwghts(etree: *mut ETree) -> *mut libc::c_int;
}
extern "C" {
    pub fn ETree_vtxToFrontIV(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_vtxToFront(etree: *mut ETree) -> *mut libc::c_int;
}
extern "C" {
    pub fn ETree_frontSize(etree: *mut ETree, J: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ETree_frontBoundarySize(etree: *mut ETree, J: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ETree_maxNindAndNent(
        etree: *mut ETree,
        symflag: libc::c_int,
        pmaxnind: *mut libc::c_int,
        pmaxnent: *mut libc::c_int,
    );
}
extern "C" {
    pub fn ETree_sizeOf(etree: *mut ETree) -> libc::c_int;
}
extern "C" {
    pub fn ETree_nFactorIndices(etree: *mut ETree) -> libc::c_int;
}
extern "C" {
    pub fn ETree_nFactorEntries(etree: *mut ETree, symflag: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ETree_nFactorOps(etree: *mut ETree, type_: libc::c_int, symflag: libc::c_int) -> f64;
}
extern "C" {
    pub fn ETree_nFactorEntriesInFront(
        etree: *mut ETree,
        symflag: libc::c_int,
        J: libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn ETree_nInternalOpsInFront(
        etree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        J: libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn ETree_nExternalOpsInFront(
        etree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        J: libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn ETree_factorEntriesIV(etree: *mut ETree, symflag: libc::c_int) -> *mut IV;
}
extern "C" {
    pub fn ETree_backwardOps(
        etree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        vwghts: *mut libc::c_int,
        symbfacIVL: *mut IVL,
    ) -> *mut DV;
}
extern "C" {
    pub fn ETree_forwardOps(etree: *mut ETree, type_: libc::c_int, symflag: libc::c_int)
        -> *mut DV;
}
extern "C" {
    pub fn ETree_expand(etree: *mut ETree, eqmapIV: *mut IV) -> *mut ETree;
}
extern "C" {
    pub fn ETree_init1(etree: *mut ETree, nfront: libc::c_int, nvtx: libc::c_int);
}
extern "C" {
    pub fn ETree_initFromGraph(etree: *mut ETree, g: *mut Graph);
}
extern "C" {
    pub fn ETree_initFromGraphWithPerms(
        etree: *mut ETree,
        g: *mut Graph,
        newToOld: *mut libc::c_int,
        oldToNew: *mut libc::c_int,
    );
}
extern "C" {
    pub fn ETree_initFromDenseMatrix(
        etree: *mut ETree,
        n: libc::c_int,
        option: libc::c_int,
        param: libc::c_int,
    );
}
extern "C" {
    pub fn ETree_initFromFile(
        frontETree: *mut ETree,
        inETreeFileName: *mut libc::c_char,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_msByDepth(etree: *mut ETree, depth: libc::c_int) -> *mut IV;
}
extern "C" {
    pub fn ETree_msByNvtxCutoff(etree: *mut ETree, cutoff: f64) -> *mut IV;
}
extern "C" {
    pub fn ETree_msByNentCutoff(etree: *mut ETree, cutoff: f64, symflag: libc::c_int) -> *mut IV;
}
extern "C" {
    pub fn ETree_msByNopsCutoff(
        etree: *mut ETree,
        cutoff: f64,
        type_: libc::c_int,
        symflag: libc::c_int,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_msStats(
        frontETree: *mut ETree,
        msIV: *mut IV,
        nvtxIV: *mut IV,
        nzfIV: *mut IV,
        opsDV: *mut DV,
        type_: libc::c_int,
        symlag: libc::c_int,
    );
}
extern "C" {
    pub fn ETree_newToOldFrontPerm(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_oldToNewFrontPerm(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_newToOldVtxPerm(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_oldToNewVtxPerm(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_permuteVertices(etree: *mut ETree, vtxOldToNewIV: *mut IV);
}
extern "C" {
    pub fn ETree_fundChainMap(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_fundSupernodeMap(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_compress(etree: *mut ETree, frontmapIV: *mut IV) -> *mut ETree;
}
extern "C" {
    pub fn ETree_leftJustify(etree: *mut ETree);
}
extern "C" {
    pub fn ETree_leftJustifyI(etree: *mut ETree, metricIV: *mut IV);
}
extern "C" {
    pub fn ETree_leftJustifyD(etree: *mut ETree, metricDV: *mut DV);
}
extern "C" {
    pub fn ETree_nvtxMetric(etree: *mut ETree) -> *mut IV;
}
extern "C" {
    pub fn ETree_nentMetric(etree: *mut ETree, flag: libc::c_int) -> *mut IV;
}
extern "C" {
    pub fn ETree_nopsMetric(etree: *mut ETree, type_: libc::c_int, symflag: libc::c_int)
        -> *mut DV;
}
extern "C" {
    pub fn ETree_stagesViaMS(etree: *mut ETree, msIV: *mut IV) -> *mut IV;
}
extern "C" {
    pub fn ETree_transform(
        etree: *mut ETree,
        vwghts: *mut libc::c_int,
        maxzeros: libc::c_int,
        maxfrontsize: libc::c_int,
        seed: libc::c_int,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_transform2(
        etree: *mut ETree,
        vwghts: *mut libc::c_int,
        maxzeros: libc::c_int,
        maxfrontsize: libc::c_int,
        seed: libc::c_int,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_mergeFrontsOne(
        etree: *mut ETree,
        maxzeros: libc::c_int,
        nzerosIV: *mut IV,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_mergeFrontsAll(
        etree: *mut ETree,
        maxzeros: libc::c_int,
        nzerosIV: *mut IV,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_mergeFrontsAny(
        etree: *mut ETree,
        maxzeros: libc::c_int,
        nzerosIV: *mut IV,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_splitFronts(
        etree: *mut ETree,
        vwghts: *mut libc::c_int,
        maxfrontsize: libc::c_int,
        seed: libc::c_int,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_wrapMap(
        frontTree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        cumopsDV: *mut DV,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_balancedMap(
        frontTree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        cumopsDV: *mut DV,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_subtreeSubsetMap(
        frontTree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        cumopsDV: *mut DV,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_ddMap(
        frontTree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        cumopsDV: *mut DV,
        cutoff: f64,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_ddMapNew(
        frontTree: *mut ETree,
        type_: libc::c_int,
        symflag: libc::c_int,
        msIV: *mut IV,
        cumopsDV: *mut DV,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_spliceTwoETrees(
        etree0: *mut ETree,
        graph0: *mut Graph,
        mapIV: *mut IV,
        etree1: *mut ETree,
    ) -> *mut ETree;
}
extern "C" {
    pub fn ETree_initFromSubtree(
        subtree: *mut ETree,
        nodeidsIV: *mut IV,
        etree: *mut ETree,
        vtxIV: *mut IV,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ETree_optPart(
        etree: *mut ETree,
        graph: *mut Graph,
        symbfacIVL: *mut IVL,
        alpha: f64,
        ptotalgain: *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn ETree_MFstackProfile(etree: *mut ETree, symflag: libc::c_int, dvec: *mut f64);
}
extern "C" {
    pub fn ETree_GSstorageProfile(
        etree: *mut ETree,
        symflag: libc::c_int,
        symbfacIVL: *mut IVL,
        vwghts: *mut libc::c_int,
        dvec: *mut f64,
    );
}
extern "C" {
    pub fn ETree_FSstorageProfile(
        etree: *mut ETree,
        symflag: libc::c_int,
        symbfacIVL: *mut IVL,
        dvec: *mut f64,
    );
}
extern "C" {
    pub fn ETree_forwSolveProfile(etree: *mut ETree, dvec: *mut f64);
}
extern "C" {
    pub fn ETree_backSolveProfile(etree: *mut ETree, dvec: *mut f64);
}
extern "C" {
    pub fn ETree_readFromFile(etree: *mut ETree, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ETree_readFromFormattedFile(etree: *mut ETree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ETree_readFromBinaryFile(etree: *mut ETree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ETree_writeToFile(etree: *mut ETree, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ETree_writeToFormattedFile(etree: *mut ETree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ETree_writeToBinaryFile(etree: *mut ETree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ETree_writeForHumanEye(etree: *mut ETree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ETree_writeStats(etree: *mut ETree, fp: *mut FILE) -> libc::c_int;
}
pub type Coords = _Coords;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Coords {
    pub type_: libc::c_int,
    pub ndim: libc::c_int,
    pub ncoor: libc::c_int,
    pub coors: *mut f32,
}
#[test]
fn bindgen_test_layout__Coords() {
    assert_eq!(
        ::std::mem::size_of::<_Coords>(),
        24usize,
        concat!("Size of: ", stringify!(_Coords))
    );
    assert_eq!(
        ::std::mem::align_of::<_Coords>(),
        8usize,
        concat!("Alignment of ", stringify!(_Coords))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Coords>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Coords),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Coords>())).ndim as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Coords),
            "::",
            stringify!(ndim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Coords>())).ncoor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Coords),
            "::",
            stringify!(ncoor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Coords>())).coors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Coords),
            "::",
            stringify!(coors)
        )
    );
}
extern "C" {
    pub fn Coords_new() -> *mut Coords;
}
extern "C" {
    pub fn Coords_setDefaultFields(coords: *mut Coords);
}
extern "C" {
    pub fn Coords_clearData(coords: *mut Coords);
}
extern "C" {
    pub fn Coords_free(coords: *mut Coords) -> *mut Coords;
}
extern "C" {
    pub fn Coords_init(
        coords: *mut Coords,
        type_: libc::c_int,
        ndim: libc::c_int,
        ncoor: libc::c_int,
    );
}
extern "C" {
    pub fn Coords_init9P(
        coords: *mut Coords,
        bbox: *mut f32,
        type_: libc::c_int,
        n1: libc::c_int,
        n2: libc::c_int,
        ncomp: libc::c_int,
    );
}
extern "C" {
    pub fn Coords_init27P(
        coords: *mut Coords,
        bbox: *mut f32,
        Type: libc::c_int,
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        ncomp: libc::c_int,
    );
}
extern "C" {
    pub fn Coords_sizeOf(coords: *mut Coords) -> libc::c_int;
}
extern "C" {
    pub fn Coords_min(coords: *mut Coords, dim: libc::c_int) -> f32;
}
extern "C" {
    pub fn Coords_max(coords: *mut Coords, dim: libc::c_int) -> f32;
}
extern "C" {
    pub fn Coords_value(coords: *mut Coords, idim: libc::c_int, icoor: libc::c_int) -> f32;
}
extern "C" {
    pub fn Coords_setValue(coords: *mut Coords, idim: libc::c_int, icoor: libc::c_int, val: f32);
}
extern "C" {
    pub fn Coords_readFromFile(coords: *mut Coords, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Coords_readFromFormattedFile(coords: *mut Coords, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Coords_readFromBinaryFile(coords: *mut Coords, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Coords_writeToFile(coords: *mut Coords, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn Coords_writeToFormattedFile(coords: *mut Coords, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Coords_writeToBinaryFile(coords: *mut Coords, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Coords_writeForHumanEye(coords: *mut Coords, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Coords_writeStats(coords: *mut Coords, fp: *mut FILE) -> libc::c_int;
}
pub type IIheap = _IIheap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IIheap {
    pub size: libc::c_int,
    pub maxsize: libc::c_int,
    pub heapLoc: *mut libc::c_int,
    pub keys: *mut libc::c_int,
    pub values: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout__IIheap() {
    assert_eq!(
        ::std::mem::size_of::<_IIheap>(),
        32usize,
        concat!("Size of: ", stringify!(_IIheap))
    );
    assert_eq!(
        ::std::mem::align_of::<_IIheap>(),
        8usize,
        concat!("Alignment of ", stringify!(_IIheap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IIheap>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IIheap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IIheap>())).maxsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IIheap),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IIheap>())).heapLoc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IIheap),
            "::",
            stringify!(heapLoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IIheap>())).keys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IIheap),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IIheap>())).values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IIheap),
            "::",
            stringify!(values)
        )
    );
}
extern "C" {
    pub fn IIheap_new() -> *mut IIheap;
}
extern "C" {
    pub fn IIheap_setDefaultFields(heap: *mut IIheap);
}
extern "C" {
    pub fn IIheap_clearData(heap: *mut IIheap);
}
extern "C" {
    pub fn IIheap_free(heap: *mut IIheap);
}
extern "C" {
    pub fn IIheap_init(heap: *mut IIheap, maxsize: libc::c_int);
}
extern "C" {
    pub fn IIheap_root(heap: *mut IIheap, pkey: *mut libc::c_int, pvalue: *mut libc::c_int);
}
extern "C" {
    pub fn IIheap_insert(heap: *mut IIheap, key: libc::c_int, value: libc::c_int);
}
extern "C" {
    pub fn IIheap_remove(heap: *mut IIheap, key: libc::c_int);
}
extern "C" {
    pub fn IIheap_print(heap: *mut IIheap, fp: *mut FILE);
}
extern "C" {
    pub fn IIheap_sizeOf(heap: *mut IIheap) -> libc::c_int;
}
pub type MSMD = _MSMD;
pub type MSMDinfo = _MSMDinfo;
pub type MSMDstageInfo = _MSMDstageInfo;
pub type MSMDvtx = _MSMDvtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSMD {
    pub nvtx: libc::c_int,
    pub heap: *mut IIheap,
    pub incrIP: libc::c_int,
    pub baseIP: *mut IP,
    pub freeIP: *mut IP,
    pub vertices: *mut MSMDvtx,
    pub ivtmpIV: IV,
    pub reachIV: IV,
}
#[test]
fn bindgen_test_layout__MSMD() {
    assert_eq!(
        ::std::mem::size_of::<_MSMD>(),
        96usize,
        concat!("Size of: ", stringify!(_MSMD))
    );
    assert_eq!(
        ::std::mem::align_of::<_MSMD>(),
        8usize,
        concat!("Alignment of ", stringify!(_MSMD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).nvtx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(nvtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).heap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).incrIP as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(incrIP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).baseIP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(baseIP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).freeIP as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(freeIP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).vertices as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).ivtmpIV as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(ivtmpIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMD>())).reachIV as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMD),
            "::",
            stringify!(reachIV)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSMDinfo {
    pub compressFlag: libc::c_int,
    pub prioType: libc::c_int,
    pub stepType: f64,
    pub seed: libc::c_int,
    pub msglvl: libc::c_int,
    pub msgFile: *mut FILE,
    pub maxnbytes: libc::c_int,
    pub nbytes: libc::c_int,
    pub istage: libc::c_int,
    pub nstage: libc::c_int,
    pub stageInfo: *mut MSMDstageInfo,
    pub totalCPU: f64,
}
#[test]
fn bindgen_test_layout__MSMDinfo() {
    assert_eq!(
        ::std::mem::size_of::<_MSMDinfo>(),
        64usize,
        concat!("Size of: ", stringify!(_MSMDinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_MSMDinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_MSMDinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).compressFlag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(compressFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).prioType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(prioType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).stepType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(stepType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).seed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).msglvl as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(msglvl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).msgFile as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(msgFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).maxnbytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(maxnbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).nbytes as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).istage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(istage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).nstage as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(nstage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).stageInfo as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(stageInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDinfo>())).totalCPU as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDinfo),
            "::",
            stringify!(totalCPU)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSMDstageInfo {
    pub nstep: libc::c_int,
    pub nfront: libc::c_int,
    pub welim: libc::c_int,
    pub nfind: libc::c_int,
    pub nzf: libc::c_int,
    pub ops: f64,
    pub nexact2: libc::c_int,
    pub nexact3: libc::c_int,
    pub napprox: libc::c_int,
    pub ncheck: libc::c_int,
    pub nindst: libc::c_int,
    pub noutmtch: libc::c_int,
    pub cpu: f64,
}
#[test]
fn bindgen_test_layout__MSMDstageInfo() {
    assert_eq!(
        ::std::mem::size_of::<_MSMDstageInfo>(),
        64usize,
        concat!("Size of: ", stringify!(_MSMDstageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_MSMDstageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_MSMDstageInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nstep as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nstep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nfront as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nfront)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).welim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(welim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nfind as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nfind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nzf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nzf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).ops as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nexact2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nexact2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nexact3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nexact3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).napprox as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(napprox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).ncheck as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(ncheck)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).nindst as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(nindst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).noutmtch as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(noutmtch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDstageInfo>())).cpu as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDstageInfo),
            "::",
            stringify!(cpu)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MSMDvtx {
    pub id: libc::c_int,
    pub mark: libc::c_char,
    pub status: libc::c_char,
    pub stage: libc::c_int,
    pub wght: libc::c_int,
    pub nadj: libc::c_int,
    pub adj: *mut libc::c_int,
    pub bndwght: libc::c_int,
    pub par: *mut MSMDvtx,
    pub subtrees: *mut IP,
}
#[test]
fn bindgen_test_layout__MSMDvtx() {
    assert_eq!(
        ::std::mem::size_of::<_MSMDvtx>(),
        56usize,
        concat!("Size of: ", stringify!(_MSMDvtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_MSMDvtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_MSMDvtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).mark as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).status as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).stage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).wght as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(wght)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).nadj as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(nadj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).adj as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(adj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).bndwght as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(bndwght)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).par as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(par)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MSMDvtx>())).subtrees as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_MSMDvtx),
            "::",
            stringify!(subtrees)
        )
    );
}
extern "C" {
    pub fn MSMDinfo_new() -> *mut MSMDinfo;
}
extern "C" {
    pub fn MSMDinfo_setDefaultFields(info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMDinfo_clearData(info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMDinfo_free(info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMDinfo_print(info: *mut MSMDinfo, fp: *mut FILE);
}
extern "C" {
    pub fn MSMDinfo_isValid(info: *mut MSMDinfo) -> libc::c_int;
}
extern "C" {
    pub fn MSMD_new() -> *mut MSMD;
}
extern "C" {
    pub fn MSMD_setDefaultFields(msmd: *mut MSMD);
}
extern "C" {
    pub fn MSMD_clearData(msmd: *mut MSMD);
}
extern "C" {
    pub fn MSMD_free(msmd: *mut MSMD);
}
extern "C" {
    pub fn MSMDvtx_print(v: *mut MSMDvtx, fp: *mut FILE);
}
extern "C" {
    pub fn MSMD_order(
        msmd: *mut MSMD,
        g: *mut Graph,
        stages: *mut libc::c_int,
        info: *mut MSMDinfo,
    );
}
extern "C" {
    pub fn MSMD_fillPerms(msmd: *mut MSMD, newToOldIV: *mut IV, oldToNewIV: *mut IV);
}
extern "C" {
    pub fn MSMD_frontETree(msmd: *mut MSMD) -> *mut ETree;
}
extern "C" {
    pub fn MSMD_init(msmd: *mut MSMD, g: *mut Graph, stages: *mut libc::c_int, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_cleanReachSet(msmd: *mut MSMD, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_cleanSubtreeList(msmd: *mut MSMD, v: *mut MSMDvtx, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_cleanEdgeList(msmd: *mut MSMD, v: *mut MSMDvtx, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_eliminateStage(msmd: *mut MSMD, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_eliminateStep(msmd: *mut MSMD, info: *mut MSMDinfo) -> libc::c_int;
}
extern "C" {
    pub fn MSMD_eliminateVtx(msmd: *mut MSMD, v: *mut MSMDvtx, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_findInodes(msmd: *mut MSMD, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_update(msmd: *mut MSMD, info: *mut MSMDinfo);
}
extern "C" {
    pub fn MSMD_exactDegree2(msmd: *mut MSMD, v: *mut MSMDvtx, info: *mut MSMDinfo) -> libc::c_int;
}
extern "C" {
    pub fn MSMD_exactDegree3(msmd: *mut MSMD, v: *mut MSMDvtx, info: *mut MSMDinfo) -> libc::c_int;
}
extern "C" {
    pub fn MSMD_approxDegree(msmd: *mut MSMD, v: *mut MSMDvtx, info: *mut MSMDinfo) -> libc::c_int;
}
extern "C" {
    pub fn MSMD_makeSchurComplement(msmd: *mut MSMD, schurGraph: *mut Graph, VtoPhiIV: *mut IV);
}
pub type BPG = _BPG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _BPG {
    pub nX: libc::c_int,
    pub nY: libc::c_int,
    pub graph: *mut Graph,
}
#[test]
fn bindgen_test_layout__BPG() {
    assert_eq!(
        ::std::mem::size_of::<_BPG>(),
        16usize,
        concat!("Size of: ", stringify!(_BPG))
    );
    assert_eq!(
        ::std::mem::align_of::<_BPG>(),
        8usize,
        concat!("Alignment of ", stringify!(_BPG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_BPG>())).nX as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_BPG), "::", stringify!(nX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_BPG>())).nY as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_BPG), "::", stringify!(nY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_BPG>())).graph as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_BPG),
            "::",
            stringify!(graph)
        )
    );
}
extern "C" {
    pub fn BPG_new() -> *mut BPG;
}
extern "C" {
    pub fn BPG_setDefaultFields(bpg: *mut BPG);
}
extern "C" {
    pub fn BPG_clearData(bpg: *mut BPG);
}
extern "C" {
    pub fn BPG_free(bpg: *mut BPG);
}
extern "C" {
    pub fn BPG_DMdecomposition(
        bpg: *mut BPG,
        dmflags: *mut libc::c_int,
        stats: *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn BPG_DMviaMaxFlow(
        bpg: *mut BPG,
        dmflags: *mut libc::c_int,
        stats: *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn BPG_init(bpg: *mut BPG, nX: libc::c_int, nY: libc::c_int, graph: *mut Graph);
}
extern "C" {
    pub fn BPG_initFromColoring(
        bpg: *mut BPG,
        graph: *mut Graph,
        colors: *mut libc::c_int,
        cX: libc::c_int,
        cY: libc::c_int,
        cmap: *mut libc::c_int,
        indX: *mut libc::c_int,
        indY: *mut libc::c_int,
    );
}
extern "C" {
    pub fn BPG_readFromFile(bpg: *mut BPG, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn BPG_readFromFormattedFile(bpg: *mut BPG, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn BPG_readFromBinaryFile(bpg: *mut BPG, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn BPG_writeToFile(bpg: *mut BPG, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn BPG_writeToFormattedFile(bpg: *mut BPG, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn BPG_writeToBinaryFile(bpg: *mut BPG, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn BPG_writeForHumanEye(bpg: *mut BPG, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn BPG_writeStats(bpg: *mut BPG, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn BPG_makeGraphXbyX(bpg: *mut BPG) -> *mut Graph;
}
extern "C" {
    pub fn BPG_makeGraphYbyY(bpg: *mut BPG) -> *mut Graph;
}
extern "C" {
    pub fn BPG_pseudoperipheralnode(bpg: *mut BPG, seed: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn BPG_levelStructure(
        bpg: *mut BPG,
        root: libc::c_int,
        list: *mut libc::c_int,
        dist: *mut libc::c_int,
        mark: *mut libc::c_int,
        tag: libc::c_int,
    ) -> libc::c_int;
}
pub type DSTree = _DSTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DSTree {
    pub tree: *mut Tree,
    pub mapIV: *mut IV,
}
#[test]
fn bindgen_test_layout__DSTree() {
    assert_eq!(
        ::std::mem::size_of::<_DSTree>(),
        16usize,
        concat!("Size of: ", stringify!(_DSTree))
    );
    assert_eq!(
        ::std::mem::align_of::<_DSTree>(),
        8usize,
        concat!("Alignment of ", stringify!(_DSTree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DSTree>())).tree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DSTree),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DSTree>())).mapIV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DSTree),
            "::",
            stringify!(mapIV)
        )
    );
}
extern "C" {
    pub fn DSTree_new() -> *mut DSTree;
}
extern "C" {
    pub fn DSTree_setDefaultFields(dstree: *mut DSTree);
}
extern "C" {
    pub fn DSTree_clearData(dstree: *mut DSTree);
}
extern "C" {
    pub fn DSTree_free(dstree: *mut DSTree);
}
extern "C" {
    pub fn DSTree_tree(dstree: *mut DSTree) -> *mut Tree;
}
extern "C" {
    pub fn DSTree_mapIV(dstree: *mut DSTree) -> *mut IV;
}
extern "C" {
    pub fn DSTree_init1(dstree: *mut DSTree, ndomsep: libc::c_int, nvtx: libc::c_int);
}
extern "C" {
    pub fn DSTree_init2(dstree: *mut DSTree, tree: *mut Tree, mapIV: *mut IV);
}
extern "C" {
    pub fn DSTree_NDstages(dstree: *mut DSTree) -> *mut IV;
}
extern "C" {
    pub fn DSTree_ND2stages(dstree: *mut DSTree) -> *mut IV;
}
extern "C" {
    pub fn DSTree_MS2stages(dstree: *mut DSTree) -> *mut IV;
}
extern "C" {
    pub fn DSTree_MS3stages(dstree: *mut DSTree) -> *mut IV;
}
extern "C" {
    pub fn DSTree_stagesViaDomainWeight(
        dstree: *mut DSTree,
        vwghts: *mut libc::c_int,
        cutoffDV: *mut DV,
    ) -> *mut IV;
}
extern "C" {
    pub fn DSTree_sizeOf(dstree: *mut DSTree) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_renumberViaPostOT(dstree: *mut DSTree);
}
extern "C" {
    pub fn DSTree_domainWeight(dstree: *mut DSTree, vwghts: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_separatorWeight(dstree: *mut DSTree, vwghts: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_readFromFile(dstree: *mut DSTree, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_readFromFormattedFile(dstree: *mut DSTree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_readFromBinaryFile(dstree: *mut DSTree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_writeToFile(dstree: *mut DSTree, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_writeToFormattedFile(dstree: *mut DSTree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_writeToBinaryFile(dstree: *mut DSTree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_writeForHumanEye(dstree: *mut DSTree, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn DSTree_writeStats(dstree: *mut DSTree, fp: *mut FILE) -> libc::c_int;
}
pub type GPart = _GPart;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPart {
    pub id: libc::c_int,
    pub g: *mut Graph,
    pub nvtx: libc::c_int,
    pub nvbnd: libc::c_int,
    pub ncomp: libc::c_int,
    pub compidsIV: IV,
    pub cweightsIV: IV,
    pub par: *mut GPart,
    pub fch: *mut GPart,
    pub sib: *mut GPart,
    pub vtxMapIV: IV,
    pub msglvl: libc::c_int,
    pub msgFile: *mut FILE,
}
#[test]
fn bindgen_test_layout__GPart() {
    assert_eq!(
        ::std::mem::size_of::<_GPart>(),
        144usize,
        concat!("Size of: ", stringify!(_GPart))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPart>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPart))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).g as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GPart), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).nvtx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(nvtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).nvbnd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(nvbnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).ncomp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(ncomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).compidsIV as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(compidsIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).cweightsIV as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(cweightsIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).par as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(par)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).fch as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(fch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).sib as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(sib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).vtxMapIV as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(vtxMapIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).msglvl as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(msglvl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPart>())).msgFile as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPart),
            "::",
            stringify!(msgFile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DDsepInfo {
    pub seed: libc::c_int,
    pub minweight: libc::c_int,
    pub maxweight: libc::c_int,
    pub freeze: f64,
    pub alpha: f64,
    pub maxcompweight: libc::c_int,
    pub ntreeobj: libc::c_int,
    pub DDoption: libc::c_int,
    pub nlayer: libc::c_int,
    pub cpuDD: f64,
    pub cpuMap: f64,
    pub cpuBPG: f64,
    pub cpuBKL: f64,
    pub cpuSmooth: f64,
    pub cpuSplit: f64,
    pub cpuTotal: f64,
    pub msglvl: libc::c_int,
    pub msgFile: *mut FILE,
}
#[test]
fn bindgen_test_layout__DDsepInfo() {
    assert_eq!(
        ::std::mem::size_of::<_DDsepInfo>(),
        120usize,
        concat!("Size of: ", stringify!(_DDsepInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_DDsepInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_DDsepInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).minweight as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(minweight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).maxweight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(maxweight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).freeze as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(freeze)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).alpha as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).maxcompweight as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(maxcompweight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).ntreeobj as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(ntreeobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).DDoption as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(DDoption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).nlayer as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(nlayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuDD as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuDD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuMap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuBPG as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuBPG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuBKL as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuBKL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuSmooth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuSmooth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuSplit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuSplit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).cpuTotal as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(cpuTotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).msglvl as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(msglvl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DDsepInfo>())).msgFile as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_DDsepInfo),
            "::",
            stringify!(msgFile)
        )
    );
}
pub type DDsepInfo = _DDsepInfo;
extern "C" {
    pub fn DDsepInfo_new() -> *mut DDsepInfo;
}
extern "C" {
    pub fn DDsepInfo_setDefaultFields(info: *mut DDsepInfo);
}
extern "C" {
    pub fn DDsepInfo_clearData(info: *mut DDsepInfo);
}
extern "C" {
    pub fn DDsepInfo_free(info: *mut DDsepInfo);
}
extern "C" {
    pub fn DDsepInfo_writeCpuTimes(info: *mut DDsepInfo, msgFile: *mut FILE);
}
extern "C" {
    pub fn GPart_new() -> *mut GPart;
}
extern "C" {
    pub fn GPart_setDefaultFields(gpart: *mut GPart);
}
extern "C" {
    pub fn GPart_clearData(gpart: *mut GPart);
}
extern "C" {
    pub fn GPart_free(gpart: *mut GPart);
}
extern "C" {
    pub fn GPart_DDviaFishnet(
        gpart: *mut GPart,
        freeze: f64,
        minweight: libc::c_int,
        maxweight: libc::c_int,
        seed: libc::c_int,
    );
}
extern "C" {
    pub fn GPart_DDviaProjection(gpart: *mut GPart, DDmapIV: *mut IV);
}
extern "C" {
    pub fn GPart_domSegMap(
        gpart: *mut GPart,
        pndom: *mut libc::c_int,
        pnseg: *mut libc::c_int,
    ) -> *mut IV;
}
extern "C" {
    pub fn GPart_identifyWideSep(
        gpart: *mut GPart,
        nlevel1: libc::c_int,
        nlevel2: libc::c_int,
    ) -> *mut IV;
}
extern "C" {
    pub fn GPart_init(gpart: *mut GPart, g: *mut Graph);
}
extern "C" {
    pub fn GPart_setMessageInfo(gpart: *mut GPart, msglvl: libc::c_int, msgFile: *mut FILE);
}
extern "C" {
    pub fn GPart_makeYCmap(gpart: *mut GPart, YVmapIV: *mut IV) -> *mut IV;
}
extern "C" {
    pub fn GPart_RBviaDDsep(gpart: *mut GPart, info: *mut DDsepInfo) -> *mut DSTree;
}
extern "C" {
    pub fn GPart_smoothBisector(gpart: *mut GPart, nlevel: libc::c_int, alpha: f32) -> f32;
}
extern "C" {
    pub fn GPart_smoothBy2layers(gpart: *mut GPart, option: libc::c_int, alpha: f32);
}
extern "C" {
    pub fn GPart_smoothYSep(
        gpart: *mut GPart,
        YVmapIV: *mut IV,
        YCmapIV: *mut IV,
        alpha: f32,
    ) -> f32;
}
extern "C" {
    pub fn GPart_split(gpart: *mut GPart);
}
extern "C" {
    pub fn GPart_TwoSetViaBKL(
        gpart: *mut GPart,
        alpha: f64,
        seed: libc::c_int,
        cpus: *mut f64,
    ) -> f64;
}
extern "C" {
    pub fn GPart_setCweights(gpart: *mut GPart);
}
extern "C" {
    pub fn GPart_sizeOf(gpart: *mut GPart) -> libc::c_int;
}
extern "C" {
    pub fn GPart_vtxIsAdjToOneDomain(
        gpart: *mut GPart,
        v: libc::c_int,
        pdomid: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GPart_validVtxSep(gpart: *mut GPart) -> libc::c_int;
}
extern "C" {
    pub fn GPart_bndWeightsIV(gpart: *mut GPart) -> *mut IV;
}
extern "C" {
    pub fn mkNDperm(
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        new_to_old: *mut libc::c_int,
        west: libc::c_int,
        east: libc::c_int,
        south: libc::c_int,
        north: libc::c_int,
        bottom: libc::c_int,
        top: libc::c_int,
    );
}
extern "C" {
    pub fn fp2DGrid(n1: libc::c_int, n2: libc::c_int, ivec: *mut libc::c_int, fp: *mut FILE);
}
extern "C" {
    pub fn fp3DGrid(
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        ivec: *mut libc::c_int,
        fp: *mut FILE,
    );
}
extern "C" {
    pub fn localND2D(
        n1: libc::c_int,
        n2: libc::c_int,
        p1: libc::c_int,
        p2: libc::c_int,
        dsizes1: *mut libc::c_int,
        dsizes2: *mut libc::c_int,
        oldToNew: *mut libc::c_int,
    );
}
extern "C" {
    pub fn localND3D(
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        p1: libc::c_int,
        p2: libc::c_int,
        p3: libc::c_int,
        dsizes1: *mut libc::c_int,
        dsizes2: *mut libc::c_int,
        dsizes3: *mut libc::c_int,
        oldToNew: *mut libc::c_int,
    );
}
extern "C" {
    pub fn orderViaBestOfNDandMS(
        graph: *mut Graph,
        maxdomainsize: libc::c_int,
        maxzeros: libc::c_int,
        maxsize: libc::c_int,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut ETree;
}
extern "C" {
    pub fn orderViaND(
        graph: *mut Graph,
        maxdomainsize: libc::c_int,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut ETree;
}
extern "C" {
    pub fn orderViaMS(
        graph: *mut Graph,
        maxdomainsize: libc::c_int,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut ETree;
}
extern "C" {
    pub fn orderViaMMD(
        graph: *mut Graph,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut ETree;
}
extern "C" {
    pub fn drawGraphEPS(
        graph: *mut Graph,
        coords: *mut Coords,
        tagsIV: *mut IV,
        bbox: *mut f64,
        rect: *mut f64,
        linewidth1: f64,
        linewidth2: f64,
        radius: f64,
        epsFileName: *mut libc::c_char,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn mkNDlinsys(
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        maxzeros: libc::c_int,
        maxsize: libc::c_int,
        type_: libc::c_int,
        symmetryflag: libc::c_int,
        nrhs: libc::c_int,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
        pfrontETree: *mut *mut ETree,
        psymbfacIVL: *mut *mut IVL,
        pmtxA: *mut *mut InpMtx,
        pmtxX: *mut *mut DenseMtx,
        pmtxB: *mut *mut DenseMtx,
    );
}
extern "C" {
    pub fn mkNDlinsysQR(
        n1: libc::c_int,
        n2: libc::c_int,
        n3: libc::c_int,
        type_: libc::c_int,
        nrhs: libc::c_int,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
        pfrontETree: *mut *mut ETree,
        psymbfacIVL: *mut *mut IVL,
        pmtxA: *mut *mut InpMtx,
        pmtxX: *mut *mut DenseMtx,
        pmtxB: *mut *mut DenseMtx,
    );
}
pub type Pencil = _Pencil;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pencil {
    pub type_: libc::c_int,
    pub symflag: libc::c_int,
    pub inpmtxA: *mut InpMtx,
    pub inpmtxB: *mut InpMtx,
    pub sigma: [f64; 2usize],
}
#[test]
fn bindgen_test_layout__Pencil() {
    assert_eq!(
        ::std::mem::size_of::<_Pencil>(),
        40usize,
        concat!("Size of: ", stringify!(_Pencil))
    );
    assert_eq!(
        ::std::mem::align_of::<_Pencil>(),
        8usize,
        concat!("Alignment of ", stringify!(_Pencil))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Pencil>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pencil),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Pencil>())).symflag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pencil),
            "::",
            stringify!(symflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Pencil>())).inpmtxA as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pencil),
            "::",
            stringify!(inpmtxA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Pencil>())).inpmtxB as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pencil),
            "::",
            stringify!(inpmtxB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Pencil>())).sigma as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Pencil),
            "::",
            stringify!(sigma)
        )
    );
}
extern "C" {
    pub fn Pencil_new() -> *mut Pencil;
}
extern "C" {
    pub fn Pencil_setDefaultFields(pencil: *mut Pencil);
}
extern "C" {
    pub fn Pencil_clearData(pencil: *mut Pencil);
}
extern "C" {
    pub fn Pencil_free(pencil: *mut Pencil) -> *mut Pencil;
}
extern "C" {
    pub fn Pencil_init(
        pencil: *mut Pencil,
        type_: libc::c_int,
        symflag: libc::c_int,
        inpmtxA: *mut InpMtx,
        sigma: *mut f64,
        inpmtxB: *mut InpMtx,
    );
}
extern "C" {
    pub fn Pencil_changeCoordType(pencil: *mut Pencil, newType: libc::c_int);
}
extern "C" {
    pub fn Pencil_changeStorageMode(pencil: *mut Pencil, newMode: libc::c_int);
}
extern "C" {
    pub fn Pencil_permute(pencil: *mut Pencil, rowOldToNewIV: *mut IV, colOldToNewIV: *mut IV);
}
extern "C" {
    pub fn Pencil_mmm(pencil: *mut Pencil, Y: *mut DenseMtx, X: *mut DenseMtx);
}
extern "C" {
    pub fn Pencil_setup(
        myid: libc::c_int,
        symflag: libc::c_int,
        inpmtxAfile: *mut libc::c_char,
        sigma: *mut f64,
        inpmtxBfile: *mut libc::c_char,
        randomflag: libc::c_int,
        drand: *mut Drand,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut Pencil;
}
extern "C" {
    pub fn Pencil_sortAndCompress(pencil: *mut Pencil);
}
extern "C" {
    pub fn Pencil_convertToVectors(pencil: *mut Pencil);
}
extern "C" {
    pub fn Pencil_mapToLowerTriangle(pencil: *mut Pencil);
}
extern "C" {
    pub fn Pencil_mapToUpperTriangle(pencil: *mut Pencil);
}
extern "C" {
    pub fn Pencil_fullAdjacency(pencil: *mut Pencil) -> *mut IVL;
}
extern "C" {
    pub fn Pencil_readFromFiles(
        pencil: *mut Pencil,
        inpmtxAfileName: *mut libc::c_char,
        inpmtxBfileName: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Pencil_writeForHumanEye(pencil: *mut Pencil, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn Pencil_writeStats(pencil: *mut Pencil, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SymbFac_initFromGraph(etree: *mut ETree, graph: *mut Graph) -> *mut IVL;
}
extern "C" {
    pub fn SymbFac_initFromInpMtx(etree: *mut ETree, inpmtx: *mut InpMtx) -> *mut IVL;
}
extern "C" {
    pub fn SymbFac_initFromPencil(etree: *mut ETree, pencil: *mut Pencil) -> *mut IVL;
}
pub type PatchAndGoInfo = _PatchAndGoInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PatchAndGoInfo {
    pub strategy: libc::c_int,
    pub toosmall: f64,
    pub fudge: f64,
    pub fudgeIV: *mut IV,
    pub fudgeDV: *mut DV,
}
#[test]
fn bindgen_test_layout__PatchAndGoInfo() {
    assert_eq!(
        ::std::mem::size_of::<_PatchAndGoInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_PatchAndGoInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_PatchAndGoInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_PatchAndGoInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PatchAndGoInfo>())).strategy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PatchAndGoInfo),
            "::",
            stringify!(strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PatchAndGoInfo>())).toosmall as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PatchAndGoInfo),
            "::",
            stringify!(toosmall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PatchAndGoInfo>())).fudge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PatchAndGoInfo),
            "::",
            stringify!(fudge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PatchAndGoInfo>())).fudgeIV as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PatchAndGoInfo),
            "::",
            stringify!(fudgeIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PatchAndGoInfo>())).fudgeDV as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PatchAndGoInfo),
            "::",
            stringify!(fudgeDV)
        )
    );
}
extern "C" {
    pub fn PatchAndGoInfo_new() -> *mut PatchAndGoInfo;
}
extern "C" {
    pub fn PatchAndGoInfo_setDefaultFields(info: *mut PatchAndGoInfo);
}
extern "C" {
    pub fn PatchAndGoInfo_clearData(info: *mut PatchAndGoInfo);
}
extern "C" {
    pub fn PatchAndGoInfo_free(info: *mut PatchAndGoInfo);
}
extern "C" {
    pub fn PatchAndGoInfo_init(
        info: *mut PatchAndGoInfo,
        strategy: libc::c_int,
        toosmall: f64,
        fudge: f64,
        storeids: libc::c_int,
        storevalues: libc::c_int,
    );
}
pub type SubMtx = _SubMtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SubMtx {
    pub type_: libc::c_int,
    pub mode: libc::c_int,
    pub rowid: libc::c_int,
    pub colid: libc::c_int,
    pub nrow: libc::c_int,
    pub ncol: libc::c_int,
    pub nent: libc::c_int,
    pub entries: *mut f64,
    pub wrkDV: DV,
    pub next: *mut SubMtx,
}
#[test]
fn bindgen_test_layout__SubMtx() {
    assert_eq!(
        ::std::mem::size_of::<_SubMtx>(),
        72usize,
        concat!("Size of: ", stringify!(_SubMtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_SubMtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_SubMtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).rowid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(rowid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).colid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(colid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).nrow as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(nrow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).ncol as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(ncol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).nent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(nent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).entries as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).wrkDV as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(wrkDV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtx>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtx),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn SubMtx_new() -> *mut SubMtx;
}
extern "C" {
    pub fn SubMtx_setDefaultFields(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_clearData(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_free(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_ids(mtx: *mut SubMtx, prowid: *mut libc::c_int, pcolid: *mut libc::c_int);
}
extern "C" {
    pub fn SubMtx_setIds(mtx: *mut SubMtx, rowid: libc::c_int, colid: libc::c_int);
}
extern "C" {
    pub fn SubMtx_dimensions(
        mtx: *mut SubMtx,
        pnrow: *mut libc::c_int,
        pncol: *mut libc::c_int,
        pnent: *mut libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_rowIndices(
        mtx: *mut SubMtx,
        pnrow: *mut libc::c_int,
        prowind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_columnIndices(
        mtx: *mut SubMtx,
        pncol: *mut libc::c_int,
        pcolind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_denseInfo(
        mtx: *mut SubMtx,
        pnrow: *mut libc::c_int,
        pncol: *mut libc::c_int,
        pinc1: *mut libc::c_int,
        pinc2: *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_sparseRowsInfo(
        mtx: *mut SubMtx,
        pnrow: *mut libc::c_int,
        pnent: *mut libc::c_int,
        psizes: *mut *mut libc::c_int,
        pindices: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_sparseColumnsInfo(
        mtx: *mut SubMtx,
        pncol: *mut libc::c_int,
        pnent: *mut libc::c_int,
        psizes: *mut *mut libc::c_int,
        pindices: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_sparseTriplesInfo(
        mtx: *mut SubMtx,
        pnent: *mut libc::c_int,
        prowids: *mut *mut libc::c_int,
        pcolids: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_denseSubrowsInfo(
        mtx: *mut SubMtx,
        pnrow: *mut libc::c_int,
        pnent: *mut libc::c_int,
        pfirstlocs: *mut *mut libc::c_int,
        psizes: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_denseSubcolumnsInfo(
        mtx: *mut SubMtx,
        pncol: *mut libc::c_int,
        pnent: *mut libc::c_int,
        pfirstlocs: *mut *mut libc::c_int,
        psizes: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_diagonalInfo(mtx: *mut SubMtx, pncol: *mut libc::c_int, pentries: *mut *mut f64);
}
extern "C" {
    pub fn SubMtx_blockDiagonalInfo(
        mtx: *mut SubMtx,
        pncol: *mut libc::c_int,
        pnent: *mut libc::c_int,
        ppivotsizes: *mut *mut libc::c_int,
        pentries: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_realEntry(
        mtx: *mut SubMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        pValue: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_complexEntry(
        mtx: *mut SubMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        pReal: *mut f64,
        pImag: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_locationOfRealEntry(
        mtx: *mut SubMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        ppValue: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_locationOfComplexEntry(
        mtx: *mut SubMtx,
        irow: libc::c_int,
        jcol: libc::c_int,
        ppReal: *mut *mut f64,
        ppImag: *mut *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_nbytesNeeded(
        type_: libc::c_int,
        mode: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        nent: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_nbytesInUse(mtx: *mut SubMtx) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_workspace(mtx: *mut SubMtx) -> *mut libc::c_void;
}
extern "C" {
    pub fn SubMtx_nbytesInWorkspace(mtx: *mut SubMtx) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_setNbytesInWorkspace(mtx: *mut SubMtx, nbytes: libc::c_int);
}
extern "C" {
    pub fn SubMtx_setFields(
        mtx: *mut SubMtx,
        type_: libc::c_int,
        mode: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        nent: libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_init(
        mtx: *mut SubMtx,
        type_: libc::c_int,
        mode: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        nent: libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_initFromBuffer(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_initRandom(
        mtx: *mut SubMtx,
        type_: libc::c_int,
        mode: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        nent: libc::c_int,
        seed: libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_initRandomUpperTriangle(
        mtx: *mut SubMtx,
        type_: libc::c_int,
        mode: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        nent: libc::c_int,
        seed: libc::c_int,
        strict: libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_initRandomLowerTriangle(
        mtx: *mut SubMtx,
        type_: libc::c_int,
        mode: libc::c_int,
        rowid: libc::c_int,
        colid: libc::c_int,
        nrow: libc::c_int,
        ncol: libc::c_int,
        nent: libc::c_int,
        seed: libc::c_int,
        strict: libc::c_int,
    );
}
extern "C" {
    pub fn SubMtx_scale1vec(mtxA: *mut SubMtx, y0: *mut f64, x0: *mut f64);
}
extern "C" {
    pub fn SubMtx_scale2vec(
        mtxA: *mut SubMtx,
        y0: *mut f64,
        y1: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_scale3vec(
        mtxA: *mut SubMtx,
        y0: *mut f64,
        y1: *mut f64,
        y2: *mut f64,
        x0: *mut f64,
        x1: *mut f64,
        x2: *mut f64,
    );
}
extern "C" {
    pub fn SubMtx_solve(mtxA: *mut SubMtx, mtxB: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_solveT(mtxA: *mut SubMtx, mtxB: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_solveH(mtxA: *mut SubMtx, mtxB: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_solveupd(mtxY: *mut SubMtx, mtxA: *mut SubMtx, mtxX: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_solveupdT(mtxY: *mut SubMtx, mtxA: *mut SubMtx, mtxX: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_solveupdH(mtxY: *mut SubMtx, mtxA: *mut SubMtx, mtxX: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_sortRowsUp(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_sortColumnsUp(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_fillRowDV(mtx: *mut SubMtx, irow: libc::c_int, rowDV: *mut DV);
}
extern "C" {
    pub fn SubMtx_fillRowZV(mtx: *mut SubMtx, irow: libc::c_int, rowZV: *mut ZV);
}
extern "C" {
    pub fn SubMtx_fillColumnDV(mtx: *mut SubMtx, icol: libc::c_int, colDV: *mut DV);
}
extern "C" {
    pub fn SubMtx_fillColumnZV(mtx: *mut SubMtx, icol: libc::c_int, colZV: *mut ZV);
}
extern "C" {
    pub fn SubMtx_maxabs(mtx: *mut SubMtx) -> f64;
}
extern "C" {
    pub fn SubMtx_zero(mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtx_readFromFile(mtx: *mut SubMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_readFromFormattedFile(mtx: *mut SubMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_readFromBinaryFile(mtx: *mut SubMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_writeToFile(mtx: *mut SubMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_writeToFormattedFile(mtx: *mut SubMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_writeToBinaryFile(mtx: *mut SubMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_writeForHumanEye(mtx: *mut SubMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_writeStats(mtx: *mut SubMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SubMtx_writeForMatlab(mtx: *mut SubMtx, mtxname: *mut libc::c_char, fp: *mut FILE);
}
pub type Chv = _Chv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Chv {
    pub id: libc::c_int,
    pub nD: libc::c_int,
    pub nL: libc::c_int,
    pub nU: libc::c_int,
    pub type_: libc::c_int,
    pub symflag: libc::c_int,
    pub rowind: *mut libc::c_int,
    pub colind: *mut libc::c_int,
    pub entries: *mut f64,
    pub wrkDV: DV,
    pub next: *mut Chv,
}
#[test]
fn bindgen_test_layout__Chv() {
    assert_eq!(
        ::std::mem::size_of::<_Chv>(),
        80usize,
        concat!("Size of: ", stringify!(_Chv))
    );
    assert_eq!(
        ::std::mem::align_of::<_Chv>(),
        8usize,
        concat!("Alignment of ", stringify!(_Chv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).id as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_Chv), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).nD as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_Chv), "::", stringify!(nD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).nL as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_Chv), "::", stringify!(nL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).nU as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(_Chv), "::", stringify!(nU))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).symflag as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(symflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).rowind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(rowind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).colind as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(colind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).wrkDV as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(wrkDV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Chv>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_Chv),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn Chv_new() -> *mut Chv;
}
extern "C" {
    pub fn Chv_setDefaultFields(chv: *mut Chv);
}
extern "C" {
    pub fn Chv_clearData(chv: *mut Chv);
}
extern "C" {
    pub fn Chv_free(chv: *mut Chv);
}
extern "C" {
    pub fn Chv_nbytesNeeded(
        nD: libc::c_int,
        nL: libc::c_int,
        nU: libc::c_int,
        type_: libc::c_int,
        symflag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_nbytesInWorkspace(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_setNbytesInWorkspace(chv: *mut Chv, nbytes: libc::c_int);
}
extern "C" {
    pub fn Chv_setFields(
        chv: *mut Chv,
        id: libc::c_int,
        nD: libc::c_int,
        nL: libc::c_int,
        nU: libc::c_int,
        type_: libc::c_int,
        symflag: libc::c_int,
    );
}
extern "C" {
    pub fn Chv_init(
        chv: *mut Chv,
        id: libc::c_int,
        nD: libc::c_int,
        nL: libc::c_int,
        nU: libc::c_int,
        type_: libc::c_int,
        symflag: libc::c_int,
    );
}
extern "C" {
    pub fn Chv_initWithPointers(
        chv: *mut Chv,
        id: libc::c_int,
        nD: libc::c_int,
        nL: libc::c_int,
        nU: libc::c_int,
        type_: libc::c_int,
        symflag: libc::c_int,
        rowind: *mut libc::c_int,
        colind: *mut libc::c_int,
        entries: *mut f64,
    );
}
extern "C" {
    pub fn Chv_initFromBuffer(chv: *mut Chv);
}
extern "C" {
    pub fn Chv_id(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_type(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_symmetryFlag(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_dimensions(
        chv: *mut Chv,
        pnD: *mut libc::c_int,
        pnL: *mut libc::c_int,
        pnU: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Chv_rowIndices(chv: *mut Chv, pnrow: *mut libc::c_int, prowind: *mut *mut libc::c_int);
}
extern "C" {
    pub fn Chv_columnIndices(
        chv: *mut Chv,
        pncol: *mut libc::c_int,
        pcolind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn Chv_nent(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_entries(chv: *mut Chv) -> *mut f64;
}
extern "C" {
    pub fn Chv_diagLocation(chv: *mut Chv, ichv: libc::c_int) -> *mut f64;
}
extern "C" {
    pub fn Chv_workspace(chv: *mut Chv) -> *mut libc::c_void;
}
extern "C" {
    pub fn Chv_realEntry(chv: *mut Chv, irow: libc::c_int, jcol: libc::c_int, pValue: *mut f64);
}
extern "C" {
    pub fn Chv_complexEntry(
        chv: *mut Chv,
        irow: libc::c_int,
        jcol: libc::c_int,
        pReal: *mut f64,
        pImag: *mut f64,
    );
}
extern "C" {
    pub fn Chv_locationOfRealEntry(
        chv: *mut Chv,
        irow: libc::c_int,
        jcol: libc::c_int,
        ppValue: *mut *mut f64,
    );
}
extern "C" {
    pub fn Chv_locationOfComplexEntry(
        chv: *mut Chv,
        irow: libc::c_int,
        jcol: libc::c_int,
        ppReal: *mut *mut f64,
        ppImag: *mut *mut f64,
    );
}
extern "C" {
    pub fn Chv_setRealEntry(chv: *mut Chv, irow: libc::c_int, jcol: libc::c_int, value: f64);
}
extern "C" {
    pub fn Chv_setComplexEntry(
        chv: *mut Chv,
        irow: libc::c_int,
        jcol: libc::c_int,
        real: f64,
        imag: f64,
    );
}
extern "C" {
    pub fn Chv_updateH(chvT: *mut Chv, mtxD: *mut SubMtx, mtxU: *mut SubMtx, tempDV: *mut DV);
}
extern "C" {
    pub fn Chv_updateS(chvT: *mut Chv, mtxD: *mut SubMtx, mtxU: *mut SubMtx, tempDV: *mut DV);
}
extern "C" {
    pub fn Chv_updateN(
        chvT: *mut Chv,
        mtxL: *mut SubMtx,
        mtxD: *mut SubMtx,
        mtxU: *mut SubMtx,
        tempDV: *mut DV,
    );
}
extern "C" {
    pub fn Chv_factorWithNoPivoting(chv: *mut Chv, info: *mut PatchAndGoInfo) -> libc::c_int;
}
extern "C" {
    pub fn Chv_factorWithPivoting(
        chv: *mut Chv,
        ndelay: libc::c_int,
        pivotflag: libc::c_int,
        pivotsizesIV: *mut IV,
        workDV: *mut DV,
        tau: f64,
        pntest: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_r1upd(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_r2upd(chv: *mut Chv) -> libc::c_int;
}
extern "C" {
    pub fn Chv_maxabsInChevron(
        chv: *mut Chv,
        ichv: libc::c_int,
        pdiagmaxabs: *mut f64,
        prowmaxabs: *mut f64,
        pcolmaxabs: *mut f64,
    );
}
extern "C" {
    pub fn Chv_zeroOffdiagonalOfChevron(chv: *mut Chv, ichv: libc::c_int);
}
extern "C" {
    pub fn Chv_swapRows(chv: *mut Chv, irow: libc::c_int, jrow: libc::c_int);
}
extern "C" {
    pub fn Chv_swapColumns(chv: *mut Chv, icol: libc::c_int, jcol: libc::c_int);
}
extern "C" {
    pub fn Chv_swapRowsAndColumns(chv: *mut Chv, ii: libc::c_int, jj: libc::c_int);
}
extern "C" {
    pub fn Chv_maxabsInDiagonal11(
        chv: *mut Chv,
        mark: *mut libc::c_int,
        tag: libc::c_int,
        pmaxval: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_maxabsInRow11(
        chv: *mut Chv,
        irow: libc::c_int,
        colmark: *mut libc::c_int,
        tag: libc::c_int,
        pmaxval: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_maxabsInColumn11(
        chv: *mut Chv,
        jcol: libc::c_int,
        rowmark: *mut libc::c_int,
        tag: libc::c_int,
        pmaxval: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_maxabsInRow(chv: *mut Chv, irow: libc::c_int, pmaxval: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn Chv_maxabsInColumn(chv: *mut Chv, jcol: libc::c_int, pmaxval: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn Chv_quasimax(
        chv: *mut Chv,
        rowmark: *mut libc::c_int,
        colmark: *mut libc::c_int,
        tag: libc::c_int,
        pirow: *mut libc::c_int,
        pjcol: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn Chv_fastBunchParlettPivot(
        chv: *mut Chv,
        mark: *mut libc::c_int,
        tag: libc::c_int,
        pirow: *mut libc::c_int,
        pjcol: *mut libc::c_int,
    );
}
extern "C" {
    pub fn Chv_findPivot(
        chv: *mut Chv,
        workDV: *mut DV,
        tau: f64,
        ndelay: libc::c_int,
        pirow: *mut libc::c_int,
        pjcol: *mut libc::c_int,
        pntest: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_addChevron(
        chv: *mut Chv,
        alpha: *mut f64,
        ichv: libc::c_int,
        chvsize: libc::c_int,
        chvind: *mut libc::c_int,
        chvent: *mut f64,
    );
}
extern "C" {
    pub fn Chv_assembleChv(chvJ: *mut Chv, chvI: *mut Chv);
}
extern "C" {
    pub fn Chv_assemblePostponedData(
        newchv: *mut Chv,
        oldchv: *mut Chv,
        firstchild: *mut Chv,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_copyEntriesToVector(
        chv: *mut Chv,
        npivot: libc::c_int,
        pivotsizes: *mut libc::c_int,
        length: libc::c_int,
        dvec: *mut f64,
        copyflag: libc::c_int,
        storeflag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_copyBigEntriesToVector(
        chv: *mut Chv,
        npivot: libc::c_int,
        pivotsizes: *mut libc::c_int,
        sizes: *mut libc::c_int,
        ivec: *mut libc::c_int,
        dvec: *mut f64,
        copyflag: libc::c_int,
        storeflag: libc::c_int,
        droptol: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_countEntries(
        chv: *mut Chv,
        npivot: libc::c_int,
        pivotsizes: *mut libc::c_int,
        countflag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_countBigEntries(
        chv: *mut Chv,
        npivot: libc::c_int,
        pivotsizes: *mut libc::c_int,
        countflag: libc::c_int,
        droptol: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Chv_copyTrailingPortion(chvI: *mut Chv, chvJ: *mut Chv, offset: libc::c_int);
}
extern "C" {
    pub fn Chv_shift(chv: *mut Chv, shift: libc::c_int);
}
extern "C" {
    pub fn Chv_maxabs(chv: *mut Chv) -> f64;
}
extern "C" {
    pub fn Chv_frobNorm(chv: *mut Chv) -> f64;
}
extern "C" {
    pub fn Chv_sub(chvJ: *mut Chv, chvI: *mut Chv);
}
extern "C" {
    pub fn Chv_zero(chv: *mut Chv);
}
extern "C" {
    pub fn Chv_fill11block(chv: *mut Chv, mtx: *mut A2);
}
extern "C" {
    pub fn Chv_fill12block(chv: *mut Chv, mtx: *mut A2);
}
extern "C" {
    pub fn Chv_fill21block(chv: *mut Chv, mtx: *mut A2);
}
extern "C" {
    pub fn Chv_writeForHumanEye(chv: *mut Chv, fp: *mut FILE);
}
extern "C" {
    pub fn Chv_writeForMatlab(chv: *mut Chv, chvname: *mut libc::c_char, fp: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: libc::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> libc::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn sched_yield() -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut libc::c_char,
        __maxsize: size_t,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut libc::c_char,
        __maxsize: size_t,
        __format: *const libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int) -> libc::c_int;
}
pub type __jmp_buf = [libc::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: libc::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: libc::c_uint = 1;
pub type _bindgen_ty_2 = libc::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: libc::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: libc::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: libc::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: libc::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: libc::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: libc::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: libc::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: libc::c_uint = 0;
pub type _bindgen_ty_3 = libc::c_uint;
pub const PTHREAD_MUTEX_STALLED: libc::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: libc::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: libc::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: libc::c_uint = 1;
pub type _bindgen_ty_4 = libc::c_uint;
pub const PTHREAD_PRIO_NONE: libc::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: libc::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: libc::c_uint = 2;
pub type _bindgen_ty_5 = libc::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: libc::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: libc::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: libc::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: libc::c_uint = 0;
pub type _bindgen_ty_6 = libc::c_uint;
pub const PTHREAD_INHERIT_SCHED: libc::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: libc::c_uint = 1;
pub type _bindgen_ty_7 = libc::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: libc::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: libc::c_uint = 1;
pub type _bindgen_ty_8 = libc::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: libc::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: libc::c_uint = 1;
pub type _bindgen_ty_9 = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __canceltype: libc::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: libc::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: libc::c_uint = 1;
pub type _bindgen_ty_10 = libc::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: libc::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: libc::c_uint = 1;
pub type _bindgen_ty_11 = libc::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut libc::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t, __scope: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut libc::c_void,
        __stacksize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut libc::c_void,
        __stacksize: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut libc::c_int,
        __param: *mut sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: libc::c_int,
        __oldstate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: libc::c_int, __oldtype: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut libc::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __cancel_arg: *mut libc::c_void,
    pub __do_it: libc::c_int,
    pub __cancel_type: libc::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: libc::c_int,
        __old_ceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t, __pointer: *const libc::c_void)
        -> libc::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
pub type Lock = _Lock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lock {
    pub mutex: *mut pthread_mutex_t,
    pub nlocks: libc::c_int,
    pub nunlocks: libc::c_int,
}
#[test]
fn bindgen_test_layout__Lock() {
    assert_eq!(
        ::std::mem::size_of::<_Lock>(),
        16usize,
        concat!("Size of: ", stringify!(_Lock))
    );
    assert_eq!(
        ::std::mem::align_of::<_Lock>(),
        8usize,
        concat!("Alignment of ", stringify!(_Lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lock>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lock>())).nlocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lock),
            "::",
            stringify!(nlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Lock>())).nunlocks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Lock),
            "::",
            stringify!(nunlocks)
        )
    );
}
extern "C" {
    pub fn Lock_new() -> *mut Lock;
}
extern "C" {
    pub fn Lock_setDefaultFields(lock: *mut Lock);
}
extern "C" {
    pub fn Lock_clearData(lock: *mut Lock);
}
extern "C" {
    pub fn Lock_free(lock: *mut Lock);
}
extern "C" {
    pub fn Lock_init(lock: *mut Lock, lockflag: libc::c_int);
}
extern "C" {
    pub fn Lock_lock(lock: *mut Lock);
}
extern "C" {
    pub fn Lock_unlock(lock: *mut Lock);
}
pub type ChvManager = _ChvManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ChvManager {
    pub head: *mut Chv,
    pub lock: *mut Lock,
    pub mode: libc::c_int,
    pub nactive: libc::c_int,
    pub nbytesactive: libc::c_int,
    pub nbytesrequested: libc::c_int,
    pub nbytesalloc: libc::c_int,
    pub nrequests: libc::c_int,
    pub nreleases: libc::c_int,
    pub nlocks: libc::c_int,
    pub nunlocks: libc::c_int,
}
#[test]
fn bindgen_test_layout__ChvManager() {
    assert_eq!(
        ::std::mem::size_of::<_ChvManager>(),
        56usize,
        concat!("Size of: ", stringify!(_ChvManager))
    );
    assert_eq!(
        ::std::mem::align_of::<_ChvManager>(),
        8usize,
        concat!("Alignment of ", stringify!(_ChvManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nactive as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nactive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nbytesactive as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nbytesactive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nbytesrequested as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nbytesrequested)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nbytesalloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nbytesalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nrequests as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nrequests)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nreleases as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nreleases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nlocks as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvManager>())).nunlocks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvManager),
            "::",
            stringify!(nunlocks)
        )
    );
}
extern "C" {
    pub fn ChvManager_new() -> *mut ChvManager;
}
extern "C" {
    pub fn ChvManager_setDefaultFields(manager: *mut ChvManager);
}
extern "C" {
    pub fn ChvManager_clearData(manager: *mut ChvManager);
}
extern "C" {
    pub fn ChvManager_free(manager: *mut ChvManager);
}
extern "C" {
    pub fn ChvManager_init(manager: *mut ChvManager, lockflag: libc::c_int, mode: libc::c_int);
}
extern "C" {
    pub fn ChvManager_newObject(
        manager: *mut ChvManager,
        id: libc::c_int,
        nD: libc::c_int,
        nL: libc::c_int,
        nU: libc::c_int,
        symflag: libc::c_int,
    ) -> *mut Chv;
}
extern "C" {
    pub fn ChvManager_newObjectOfSizeNbytes(
        manager: *mut ChvManager,
        nbytesNeeded: libc::c_int,
    ) -> *mut Chv;
}
extern "C" {
    pub fn ChvManager_releaseObject(manager: *mut ChvManager, chv: *mut Chv);
}
extern "C" {
    pub fn ChvManager_releaseListOfObjects(manager: *mut ChvManager, head: *mut Chv);
}
extern "C" {
    pub fn ChvManager_writeForHumanEye(manager: *mut ChvManager, fp: *mut FILE);
}
pub type ChvList = _ChvList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ChvList {
    pub nlist: libc::c_int,
    pub heads: *mut *mut Chv,
    pub counts: *mut libc::c_int,
    pub lock: *mut Lock,
    pub flags: *mut libc::c_char,
    pub nlocks: libc::c_int,
}
#[test]
fn bindgen_test_layout__ChvList() {
    assert_eq!(
        ::std::mem::size_of::<_ChvList>(),
        48usize,
        concat!("Size of: ", stringify!(_ChvList))
    );
    assert_eq!(
        ::std::mem::align_of::<_ChvList>(),
        8usize,
        concat!("Alignment of ", stringify!(_ChvList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvList>())).nlist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvList),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvList>())).heads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvList),
            "::",
            stringify!(heads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvList>())).counts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvList),
            "::",
            stringify!(counts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvList>())).lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvList),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvList>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvList),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ChvList>())).nlocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ChvList),
            "::",
            stringify!(nlocks)
        )
    );
}
extern "C" {
    pub fn ChvList_new() -> *mut ChvList;
}
extern "C" {
    pub fn ChvList_setDefaultFields(chvlist: *mut ChvList);
}
extern "C" {
    pub fn ChvList_clearData(chvlist: *mut ChvList);
}
extern "C" {
    pub fn ChvList_free(chvlist: *mut ChvList);
}
extern "C" {
    pub fn ChvList_init(
        chvlist: *mut ChvList,
        nlist: libc::c_int,
        counts: *mut libc::c_int,
        lockflag: libc::c_int,
        flags: *mut libc::c_char,
    );
}
extern "C" {
    pub fn ChvList_writeForHumanEye(chvlist: *mut ChvList, fp: *mut FILE);
}
extern "C" {
    pub fn ChvList_isListNonempty(chvlist: *mut ChvList, ilist: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ChvList_isCountZero(chvlist: *mut ChvList, ilist: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ChvList_addObjectToList(chvlist: *mut ChvList, chv: *mut Chv, ilist: libc::c_int);
}
extern "C" {
    pub fn ChvList_getList(chvlist: *mut ChvList, ilist: libc::c_int) -> *mut Chv;
}
pub type SubMtxList = _SubMtxList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SubMtxList {
    pub nlist: libc::c_int,
    pub heads: *mut *mut SubMtx,
    pub counts: *mut libc::c_int,
    pub lock: *mut Lock,
    pub flags: *mut libc::c_char,
    pub nlocks: libc::c_int,
}
#[test]
fn bindgen_test_layout__SubMtxList() {
    assert_eq!(
        ::std::mem::size_of::<_SubMtxList>(),
        48usize,
        concat!("Size of: ", stringify!(_SubMtxList))
    );
    assert_eq!(
        ::std::mem::align_of::<_SubMtxList>(),
        8usize,
        concat!("Alignment of ", stringify!(_SubMtxList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxList>())).nlist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxList),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxList>())).heads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxList),
            "::",
            stringify!(heads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxList>())).counts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxList),
            "::",
            stringify!(counts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxList>())).lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxList),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxList>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxList),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxList>())).nlocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxList),
            "::",
            stringify!(nlocks)
        )
    );
}
extern "C" {
    pub fn SubMtxList_new() -> *mut SubMtxList;
}
extern "C" {
    pub fn SubMtxList_setDefaultFields(list: *mut SubMtxList);
}
extern "C" {
    pub fn SubMtxList_clearData(list: *mut SubMtxList);
}
extern "C" {
    pub fn SubMtxList_free(list: *mut SubMtxList);
}
extern "C" {
    pub fn SubMtxList_init(
        list: *mut SubMtxList,
        nlist: libc::c_int,
        counts: *mut libc::c_int,
        lockflag: libc::c_int,
        flags: *mut libc::c_char,
    );
}
extern "C" {
    pub fn SubMtxList_writeForHumanEye(list: *mut SubMtxList, fp: *mut FILE);
}
extern "C" {
    pub fn SubMtxList_isListNonempty(list: *mut SubMtxList, ilist: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SubMtxList_isCountZero(list: *mut SubMtxList, ilist: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SubMtxList_addObjectToList(list: *mut SubMtxList, obj: *mut SubMtx, ilist: libc::c_int);
}
extern "C" {
    pub fn SubMtxList_getList(list: *mut SubMtxList, ilist: libc::c_int) -> *mut SubMtx;
}
pub type SubMtxManager = _SubMtxManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SubMtxManager {
    pub head: *mut SubMtx,
    pub lock: *mut Lock,
    pub mode: libc::c_int,
    pub nactive: libc::c_int,
    pub nbytesactive: libc::c_int,
    pub nbytesrequested: libc::c_int,
    pub nbytesalloc: libc::c_int,
    pub nrequests: libc::c_int,
    pub nreleases: libc::c_int,
    pub nlocks: libc::c_int,
    pub nunlocks: libc::c_int,
}
#[test]
fn bindgen_test_layout__SubMtxManager() {
    assert_eq!(
        ::std::mem::size_of::<_SubMtxManager>(),
        56usize,
        concat!("Size of: ", stringify!(_SubMtxManager))
    );
    assert_eq!(
        ::std::mem::align_of::<_SubMtxManager>(),
        8usize,
        concat!("Alignment of ", stringify!(_SubMtxManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nactive as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nactive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nbytesactive as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nbytesactive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nbytesrequested as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nbytesrequested)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nbytesalloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nbytesalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nrequests as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nrequests)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nreleases as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nreleases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nlocks as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SubMtxManager>())).nunlocks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SubMtxManager),
            "::",
            stringify!(nunlocks)
        )
    );
}
extern "C" {
    pub fn SubMtxManager_new() -> *mut SubMtxManager;
}
extern "C" {
    pub fn SubMtxManager_setDefaultFields(manager: *mut SubMtxManager);
}
extern "C" {
    pub fn SubMtxManager_clearData(manager: *mut SubMtxManager);
}
extern "C" {
    pub fn SubMtxManager_free(manager: *mut SubMtxManager);
}
extern "C" {
    pub fn SubMtxManager_init(
        manager: *mut SubMtxManager,
        lockflag: libc::c_int,
        mode: libc::c_int,
    );
}
extern "C" {
    pub fn SubMtxManager_newObjectOfSizeNbytes(
        manager: *mut SubMtxManager,
        nbytesNeeded: libc::c_int,
    ) -> *mut SubMtx;
}
extern "C" {
    pub fn SubMtxManager_releaseObject(manager: *mut SubMtxManager, mtx: *mut SubMtx);
}
extern "C" {
    pub fn SubMtxManager_releaseListOfObjects(manager: *mut SubMtxManager, head: *mut SubMtx);
}
extern "C" {
    pub fn SubMtxManager_writeForHumanEye(manager: *mut SubMtxManager, fp: *mut FILE);
}
pub type Ideq = _Ideq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Ideq {
    pub maxsize: libc::c_int,
    pub head: libc::c_int,
    pub tail: libc::c_int,
    pub iv: IV,
}
#[test]
fn bindgen_test_layout__Ideq() {
    assert_eq!(
        ::std::mem::size_of::<_Ideq>(),
        40usize,
        concat!("Size of: ", stringify!(_Ideq))
    );
    assert_eq!(
        ::std::mem::align_of::<_Ideq>(),
        8usize,
        concat!("Alignment of ", stringify!(_Ideq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ideq>())).maxsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ideq),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ideq>())).head as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ideq),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ideq>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Ideq),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Ideq>())).iv as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_Ideq), "::", stringify!(iv))
    );
}
extern "C" {
    pub fn Ideq_new() -> *mut Ideq;
}
extern "C" {
    pub fn Ideq_setDefaultFields(deq: *mut Ideq);
}
extern "C" {
    pub fn Ideq_clearData(deq: *mut Ideq);
}
extern "C" {
    pub fn Ideq_free(deq: *mut Ideq);
}
extern "C" {
    pub fn Ideq_resize(deq: *mut Ideq, newsize: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_clear(deq: *mut Ideq);
}
extern "C" {
    pub fn Ideq_head(deq: *mut Ideq) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_removeFromHead(deq: *mut Ideq) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_insertAtHead(deq: *mut Ideq, val: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_tail(deq: *mut Ideq) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_removeFromTail(deq: *mut Ideq) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_insertAtTail(deq: *mut Ideq, val: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn Ideq_writeForHumanEye(dequeue: *mut Ideq, fp: *mut FILE);
}
pub type SolveMap = _SolveMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SolveMap {
    pub symmetryflag: libc::c_int,
    pub nfront: libc::c_int,
    pub nproc: libc::c_int,
    pub owners: *mut libc::c_int,
    pub nblockUpper: libc::c_int,
    pub rowidsUpper: *mut libc::c_int,
    pub colidsUpper: *mut libc::c_int,
    pub mapUpper: *mut libc::c_int,
    pub nblockLower: libc::c_int,
    pub rowidsLower: *mut libc::c_int,
    pub colidsLower: *mut libc::c_int,
    pub mapLower: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout__SolveMap() {
    assert_eq!(
        ::std::mem::size_of::<_SolveMap>(),
        88usize,
        concat!("Size of: ", stringify!(_SolveMap))
    );
    assert_eq!(
        ::std::mem::align_of::<_SolveMap>(),
        8usize,
        concat!("Alignment of ", stringify!(_SolveMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).symmetryflag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(symmetryflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).nfront as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(nfront)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).nproc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(nproc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).owners as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(owners)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).nblockUpper as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(nblockUpper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).rowidsUpper as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(rowidsUpper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).colidsUpper as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(colidsUpper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).mapUpper as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(mapUpper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).nblockLower as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(nblockLower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).rowidsLower as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(rowidsLower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).colidsLower as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(colidsLower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SolveMap>())).mapLower as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SolveMap),
            "::",
            stringify!(mapLower)
        )
    );
}
extern "C" {
    pub fn SolveMap_new() -> *mut SolveMap;
}
extern "C" {
    pub fn SolveMap_setDefaultFields(solvemap: *mut SolveMap);
}
extern "C" {
    pub fn SolveMap_clearData(solvemap: *mut SolveMap);
}
extern "C" {
    pub fn SolveMap_free(solvemap: *mut SolveMap) -> *mut SolveMap;
}
extern "C" {
    pub fn SolveMap_symmetryflag(solvemap: *mut SolveMap) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_nfront(solvemap: *mut SolveMap) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_nproc(solvemap: *mut SolveMap) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_nblockUpper(solvemap: *mut SolveMap) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_nblockLower(solvemap: *mut SolveMap) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_owners(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_rowidsUpper(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_colidsUpper(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_mapUpper(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_rowidsLower(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_colidsLower(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_mapLower(solvemap: *mut SolveMap) -> *mut libc::c_int;
}
extern "C" {
    pub fn SolveMap_init(
        solvemap: *mut SolveMap,
        symmetryflag: libc::c_int,
        nfront: libc::c_int,
        nproc: libc::c_int,
        nblockUpper: libc::c_int,
        nblockLower: libc::c_int,
    );
}
extern "C" {
    pub fn SolveMap_randomMap(
        solvemap: *mut SolveMap,
        symmetryflag: libc::c_int,
        upperBlockIVL: *mut IVL,
        lowerBlockIVL: *mut IVL,
        nproc: libc::c_int,
        ownersIV: *mut IV,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn SolveMap_ddMap(
        solvemap: *mut SolveMap,
        symmetryflag: libc::c_int,
        upperBlockIVL: *mut IVL,
        lowerBlockIVL: *mut IVL,
        nproc: libc::c_int,
        ownersIV: *mut IV,
        tree: *mut Tree,
        seed: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn SolveMap_forwardSetup(
        solvemap: *mut SolveMap,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut *mut IP;
}
extern "C" {
    pub fn SolveMap_backwardSetup(
        solvemap: *mut SolveMap,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut *mut IP;
}
extern "C" {
    pub fn SolveMap_owner(
        solvemap: *mut SolveMap,
        rowid: libc::c_int,
        colid: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_upperSolveIVL(
        solvemap: *mut SolveMap,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IVL;
}
extern "C" {
    pub fn SolveMap_upperAggregateIV(
        solvemap: *mut SolveMap,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn SolveMap_lowerAggregateIV(
        solvemap: *mut SolveMap,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn SolveMap_lowerSolveIVL(
        solvemap: *mut SolveMap,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IVL;
}
extern "C" {
    pub fn SolveMap_readFromFile(solvemap: *mut SolveMap, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_readFromFormattedFile(solvemap: *mut SolveMap, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_readFromBinaryFile(solvemap: *mut SolveMap, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_writeToFile(solvemap: *mut SolveMap, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_writeToFormattedFile(solvemap: *mut SolveMap, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_writeToBinaryFile(solvemap: *mut SolveMap, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_writeForHumanEye(solvemap: *mut SolveMap, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn SolveMap_writeStats(solvemap: *mut SolveMap, fp: *mut FILE) -> libc::c_int;
}
pub type I2Ohash = _I2Ohash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _I2Ohash {
    pub nlist: libc::c_int,
    pub grow: libc::c_int,
    pub nitem: libc::c_int,
    pub baseI2OP: *mut I2OP,
    pub freeI2OP: *mut I2OP,
    pub heads: *mut *mut I2OP,
}
#[test]
fn bindgen_test_layout__I2Ohash() {
    assert_eq!(
        ::std::mem::size_of::<_I2Ohash>(),
        40usize,
        concat!("Size of: ", stringify!(_I2Ohash))
    );
    assert_eq!(
        ::std::mem::align_of::<_I2Ohash>(),
        8usize,
        concat!("Alignment of ", stringify!(_I2Ohash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2Ohash>())).nlist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2Ohash),
            "::",
            stringify!(nlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2Ohash>())).grow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2Ohash),
            "::",
            stringify!(grow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2Ohash>())).nitem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2Ohash),
            "::",
            stringify!(nitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2Ohash>())).baseI2OP as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2Ohash),
            "::",
            stringify!(baseI2OP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2Ohash>())).freeI2OP as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2Ohash),
            "::",
            stringify!(freeI2OP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_I2Ohash>())).heads as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_I2Ohash),
            "::",
            stringify!(heads)
        )
    );
}
extern "C" {
    pub fn I2Ohash_new() -> *mut I2Ohash;
}
extern "C" {
    pub fn I2Ohash_setDefaultFields(hashtbl: *mut I2Ohash);
}
extern "C" {
    pub fn I2Ohash_clearData(hashtbl: *mut I2Ohash);
}
extern "C" {
    pub fn I2Ohash_free(hashtbl: *mut I2Ohash);
}
extern "C" {
    pub fn I2Ohash_init(
        hashtbl: *mut I2Ohash,
        nlist: libc::c_int,
        nobj: libc::c_int,
        grow: libc::c_int,
    );
}
extern "C" {
    pub fn I2Ohash_insert(
        hashtbl: *mut I2Ohash,
        key1: libc::c_int,
        key2: libc::c_int,
        value: *mut libc::c_void,
    );
}
extern "C" {
    pub fn I2Ohash_locate(
        hashtbl: *mut I2Ohash,
        key1: libc::c_int,
        key2: libc::c_int,
        pvalue: *mut *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn I2Ohash_remove(
        hashtbl: *mut I2Ohash,
        key1: libc::c_int,
        key2: libc::c_int,
        pvalue: *mut *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn I2Ohash_measure(hashtbl: *mut I2Ohash) -> f64;
}
extern "C" {
    pub fn I2Ohash_writeForHumanEye(hashtbl: *mut I2Ohash, fp: *mut FILE);
}
pub type FrontMtx = _FrontMtx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FrontMtx {
    pub nfront: libc::c_int,
    pub neqns: libc::c_int,
    pub type_: libc::c_int,
    pub symmetryflag: libc::c_int,
    pub sparsityflag: libc::c_int,
    pub pivotingflag: libc::c_int,
    pub dataMode: libc::c_int,
    pub nentD: libc::c_int,
    pub nentL: libc::c_int,
    pub nentU: libc::c_int,
    pub tree: *mut Tree,
    pub frontETree: *mut ETree,
    pub frontsizesIV: *mut IV,
    pub symbfacIVL: *mut IVL,
    pub rowadjIVL: *mut IVL,
    pub coladjIVL: *mut IVL,
    pub lowerblockIVL: *mut IVL,
    pub upperblockIVL: *mut IVL,
    pub p_mtxDJJ: *mut *mut SubMtx,
    pub p_mtxUJJ: *mut *mut SubMtx,
    pub p_mtxUJN: *mut *mut SubMtx,
    pub p_mtxLJJ: *mut *mut SubMtx,
    pub p_mtxLNJ: *mut *mut SubMtx,
    pub lowerhash: *mut I2Ohash,
    pub upperhash: *mut I2Ohash,
    pub manager: *mut SubMtxManager,
    pub lock: *mut Lock,
    pub patchinfo: *mut PatchAndGoInfo,
    pub nlocks: libc::c_int,
}
#[test]
fn bindgen_test_layout__FrontMtx() {
    assert_eq!(
        ::std::mem::size_of::<_FrontMtx>(),
        192usize,
        concat!("Size of: ", stringify!(_FrontMtx))
    );
    assert_eq!(
        ::std::mem::align_of::<_FrontMtx>(),
        8usize,
        concat!("Alignment of ", stringify!(_FrontMtx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).nfront as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(nfront)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).neqns as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(neqns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).symmetryflag as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(symmetryflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).sparsityflag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(sparsityflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).pivotingflag as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(pivotingflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).dataMode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(dataMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).nentD as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(nentD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).nentL as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(nentL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).nentU as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(nentU)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).tree as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).frontETree as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(frontETree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).frontsizesIV as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(frontsizesIV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).symbfacIVL as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(symbfacIVL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).rowadjIVL as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(rowadjIVL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).coladjIVL as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(coladjIVL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).lowerblockIVL as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(lowerblockIVL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).upperblockIVL as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(upperblockIVL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).p_mtxDJJ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(p_mtxDJJ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).p_mtxUJJ as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(p_mtxUJJ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).p_mtxUJN as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(p_mtxUJN)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).p_mtxLJJ as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(p_mtxLJJ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).p_mtxLNJ as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(p_mtxLNJ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).lowerhash as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(lowerhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).upperhash as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(upperhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).manager as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(manager)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).lock as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).patchinfo as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(patchinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FrontMtx>())).nlocks as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FrontMtx),
            "::",
            stringify!(nlocks)
        )
    );
}
extern "C" {
    pub fn FrontMtx_new() -> *mut FrontMtx;
}
extern "C" {
    pub fn FrontMtx_setDefaultFields(frontmtx: *mut FrontMtx);
}
extern "C" {
    pub fn FrontMtx_clearData(frontmtx: *mut FrontMtx);
}
extern "C" {
    pub fn FrontMtx_free(frontmtx: *mut FrontMtx);
}
extern "C" {
    pub fn FrontMtx_nfront(frontmtx: *mut FrontMtx) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_neqns(frontmtx: *mut FrontMtx) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_frontTree(frontmtx: *mut FrontMtx) -> *mut Tree;
}
extern "C" {
    pub fn FrontMtx_initialFrontDimensions(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        pnD: *mut libc::c_int,
        pnL: *mut libc::c_int,
        pnU: *mut libc::c_int,
        pnbytes: *mut libc::c_int,
    );
}
extern "C" {
    pub fn FrontMtx_frontSize(frontmtx: *mut FrontMtx, J: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_setFrontSize(frontmtx: *mut FrontMtx, J: libc::c_int, size: libc::c_int);
}
extern "C" {
    pub fn FrontMtx_columnIndices(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        pncol: *mut libc::c_int,
        pcolind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn FrontMtx_rowIndices(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        pnrow: *mut libc::c_int,
        prowind: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn FrontMtx_diagMtx(frontmtx: *mut FrontMtx, J: libc::c_int) -> *mut SubMtx;
}
extern "C" {
    pub fn FrontMtx_upperMtx(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        K: libc::c_int,
    ) -> *mut SubMtx;
}
extern "C" {
    pub fn FrontMtx_lowerMtx(
        frontmtx: *mut FrontMtx,
        K: libc::c_int,
        J: libc::c_int,
    ) -> *mut SubMtx;
}
extern "C" {
    pub fn FrontMtx_lowerAdjFronts(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        pnadj: *mut libc::c_int,
        padj: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn FrontMtx_upperAdjFronts(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        pnadj: *mut libc::c_int,
        padj: *mut *mut libc::c_int,
    );
}
extern "C" {
    pub fn FrontMtx_nLowerBlocks(frontmtx: *mut FrontMtx) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_nUpperBlocks(frontmtx: *mut FrontMtx) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_upperBlockIVL(frontmtx: *mut FrontMtx) -> *mut IVL;
}
extern "C" {
    pub fn FrontMtx_lowerBlockIVL(frontmtx: *mut FrontMtx) -> *mut IVL;
}
extern "C" {
    pub fn FrontMtx_init(
        frontmtx: *mut FrontMtx,
        frontETree: *mut ETree,
        symbfacIVL: *mut IVL,
        type_: libc::c_int,
        symmetryflag: libc::c_int,
        sparsityflag: libc::c_int,
        pivotingflag: libc::c_int,
        lockflag: libc::c_int,
        myid: libc::c_int,
        ownersIV: *mut IV,
        manager: *mut SubMtxManager,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_factorInpMtx(
        frontmtx: *mut FrontMtx,
        inpmtx: *mut InpMtx,
        tau: f64,
        droptol: f64,
        chvmanager: *mut ChvManager,
        perror: *mut libc::c_int,
        cpus: *mut f64,
        stats: *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut Chv;
}
extern "C" {
    pub fn FrontMtx_factorPencil(
        frontmtx: *mut FrontMtx,
        pencil: *mut Pencil,
        tau: f64,
        droptol: f64,
        chvmanager: *mut ChvManager,
        perror: *mut libc::c_int,
        cpus: *mut f64,
        stats: *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut Chv;
}
extern "C" {
    pub fn FrontMtx_initializeFront(frontmtx: *mut FrontMtx, frontJ: *mut Chv, J: libc::c_int);
}
extern "C" {
    pub fn FrontMtx_factorVisit(
        frontmtx: *mut FrontMtx,
        pencil: *mut Pencil,
        J: libc::c_int,
        myid: libc::c_int,
        owners: *mut libc::c_int,
        fronts: *mut *mut Chv,
        lookahead: libc::c_int,
        tau: f64,
        droptol: f64,
        status: *mut libc::c_char,
        heads: *mut *mut IP,
        pivotsizesIV: *mut IV,
        workDV: *mut DV,
        parent: *mut libc::c_int,
        aggList: *mut ChvList,
        postList: *mut ChvList,
        chvmanager: *mut ChvManager,
        stats: *mut libc::c_int,
        cpus: *mut f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> libc::c_char;
}
extern "C" {
    pub fn FrontMtx_setupFront(
        frontmtx: *mut FrontMtx,
        pencil: *mut Pencil,
        J: libc::c_int,
        myid: libc::c_int,
        owners: *mut libc::c_int,
        chvmanager: *mut ChvManager,
        cpus: *mut f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut Chv;
}
extern "C" {
    pub fn FrontMtx_factorSetup(
        frontmtx: *mut FrontMtx,
        frontOwnersIV: *mut IV,
        myid: libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut *mut IP;
}
extern "C" {
    pub fn FrontMtx_nactiveChild(
        frontmtx: *mut FrontMtx,
        status: *mut libc::c_char,
        myid: libc::c_int,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn FrontMtx_setUpDequeue(
        frontmtx: *mut FrontMtx,
        owners: *mut libc::c_int,
        myid: libc::c_int,
        status: *mut libc::c_char,
        heads: *mut *mut IP,
        activeFlag: libc::c_char,
        inactiveFlag: libc::c_char,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut Ideq;
}
extern "C" {
    pub fn FrontMtx_loadActiveLeaves(
        frontmtx: *mut FrontMtx,
        status: *mut libc::c_char,
        activeFlag: libc::c_char,
        dequeue: *mut Ideq,
    );
}
extern "C" {
    pub fn FrontMtx_postList(
        frontmtx: *mut FrontMtx,
        frontOwnersIV: *mut IV,
        lockflag: libc::c_int,
    ) -> *mut ChvList;
}
extern "C" {
    pub fn FrontMtx_aggregateList(
        frontmtx: *mut FrontMtx,
        frontOwnersIV: *mut IV,
        lockflag: libc::c_int,
    ) -> *mut ChvList;
}
extern "C" {
    pub fn FrontMtx_loadEntries(
        chv: *mut Chv,
        pencil: *mut Pencil,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_update(
        frontmtx: *mut FrontMtx,
        frontJ: *mut Chv,
        heads: *mut *mut IP,
        status: *mut libc::c_char,
        tempDV: *mut DV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_assemblePostponedData(
        frontmtx: *mut FrontMtx,
        frontJ: *mut Chv,
        chvlist: *mut ChvList,
        chvmanager: *mut ChvManager,
        pndelay: *mut libc::c_int,
    ) -> *mut Chv;
}
extern "C" {
    pub fn FrontMtx_storePostponedData(
        frontmtx: *mut FrontMtx,
        frontJ: *mut Chv,
        npost: libc::c_int,
        K: libc::c_int,
        chvlist: *mut ChvList,
        chvmanager: *mut ChvManager,
    );
}
extern "C" {
    pub fn FrontMtx_storeFront(
        frontmtx: *mut FrontMtx,
        frontJ: *mut Chv,
        pivotsizesIV: *mut IV,
        droptol: f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_postProcess(frontmtx: *mut FrontMtx, msglvl: libc::c_int, msgFile: *mut FILE);
}
extern "C" {
    pub fn FrontMtx_permuteUpperAdj(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_permuteLowerAdj(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_permuteUpperMatrices(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_permuteLowerMatrices(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_splitUpperMatrices(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_splitLowerMatrices(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_solve(
        frontmtx: *mut FrontMtx,
        solmtx: *mut DenseMtx,
        rhsmtx: *mut DenseMtx,
        mtxmanager: *mut SubMtxManager,
        cpus: *mut f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_loadRightHandSide(
        frontmtx: *mut FrontMtx,
        rhsmtx: *mut DenseMtx,
        owners: *mut libc::c_int,
        myid: libc::c_int,
        mtxmanager: *mut SubMtxManager,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut *mut SubMtx;
}
extern "C" {
    pub fn FrontMtx_forwardVisit(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        nrhs: libc::c_int,
        owners: *mut libc::c_int,
        myid: libc::c_int,
        mtxmanager: *mut SubMtxManager,
        aggList: *mut SubMtxList,
        p_mtx: *mut *mut SubMtx,
        frontIsDone: *mut libc::c_char,
        heads: *mut *mut IP,
        p_agg: *mut *mut SubMtx,
        status: *mut libc::c_char,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_diagonalVisit(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        owners: *mut libc::c_int,
        myid: libc::c_int,
        p_mtx: *mut *mut SubMtx,
        frontIsDone: *mut libc::c_char,
        p_agg: *mut *mut SubMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_backwardVisit(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        nrhs: libc::c_int,
        owners: *mut libc::c_int,
        myid: libc::c_int,
        mtxmanager: *mut SubMtxManager,
        aggList: *mut SubMtxList,
        p_mtx: *mut *mut SubMtx,
        frontIsDone: *mut libc::c_char,
        heads: *mut *mut IP,
        p_agg: *mut *mut SubMtx,
        status: *mut libc::c_char,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_storeSolution(
        frontmtx: *mut FrontMtx,
        owners: *mut libc::c_int,
        myid: libc::c_int,
        manager: *mut SubMtxManager,
        p_mtx: *mut *mut SubMtx,
        solmtx: *mut DenseMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_loadActiveRoots(
        frontmtx: *mut FrontMtx,
        status: *mut libc::c_char,
        activeFlag: libc::c_char,
        dequeue: *mut Ideq,
    );
}
extern "C" {
    pub fn FrontMtx_forwardSetup(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut *mut IP;
}
extern "C" {
    pub fn FrontMtx_backwardSetup(
        frontmtx: *mut FrontMtx,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut *mut IP;
}
extern "C" {
    pub fn FrontMtx_QR_factor(
        frontmtx: *mut FrontMtx,
        mtxA: *mut InpMtx,
        chvmanager: *mut ChvManager,
        cpus: *mut f64,
        pfacops: *mut f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_QR_solve(
        frontmtx: *mut FrontMtx,
        mtxA: *mut InpMtx,
        mtxX: *mut DenseMtx,
        mtxB: *mut DenseMtx,
        manager: *mut SubMtxManager,
        cpus: *mut f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_QR_setup(
        frontmtx: *mut FrontMtx,
        mtxA: *mut InpMtx,
        prowsIVL: *mut *mut IVL,
        pfirstnz: *mut *mut libc::c_int,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_QR_factorVisit(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        mtxA: *mut InpMtx,
        rowsIVL: *mut IVL,
        firstnz: *mut libc::c_int,
        updlist: *mut ChvList,
        chvmanager: *mut ChvManager,
        status: *mut libc::c_char,
        colmap: *mut libc::c_int,
        workDV: *mut DV,
        cpus: *mut f64,
        pfacops: *mut f64,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_QR_assembleFront(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        mtxA: *mut InpMtx,
        rowsIVL: *mut IVL,
        firstnz: *mut libc::c_int,
        colmap: *mut libc::c_int,
        firstchild: *mut Chv,
        workDV: *mut DV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut A2;
}
extern "C" {
    pub fn FrontMtx_QR_storeFront(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        frontJ: *mut A2,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    );
}
extern "C" {
    pub fn FrontMtx_QR_storeUpdate(
        frontmtx: *mut FrontMtx,
        J: libc::c_int,
        frontJ: *mut A2,
        chvmanager: *mut ChvManager,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut Chv;
}
extern "C" {
    pub fn FrontMtx_colmapIV(frontmtx: *mut FrontMtx) -> *mut IV;
}
extern "C" {
    pub fn FrontMtx_rowmapIV(frontmtx: *mut FrontMtx) -> *mut IV;
}
extern "C" {
    pub fn FrontMtx_inertia(
        frontmtx: *mut FrontMtx,
        pnnegative: *mut libc::c_int,
        pnzero: *mut libc::c_int,
        pnpositive: *mut libc::c_int,
    );
}
extern "C" {
    pub fn FrontMtx_ownedRowsIV(
        frontmtx: *mut FrontMtx,
        myid: libc::c_int,
        ownersIV: *mut IV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn FrontMtx_ownedColumnsIV(
        frontmtx: *mut FrontMtx,
        myid: libc::c_int,
        ownersIV: *mut IV,
        msglvl: libc::c_int,
        msgFile: *mut FILE,
    ) -> *mut IV;
}
extern "C" {
    pub fn FrontMtx_makeUpperBlockIVL(frontmtx: *mut FrontMtx, colmapIV: *mut IV) -> *mut IVL;
}
extern "C" {
    pub fn FrontMtx_makeLowerBlockIVL(frontmtx: *mut FrontMtx, rowmapIV: *mut IV) -> *mut IVL;
}
extern "C" {
    pub fn FrontMtx_nSolveOps(frontmtx: *mut FrontMtx) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_readFromFile(frontmtx: *mut FrontMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_readFromFormattedFile(frontmtx: *mut FrontMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_readFromBinaryFile(frontmtx: *mut FrontMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_writeToFile(frontmtx: *mut FrontMtx, fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_writeToFormattedFile(frontmtx: *mut FrontMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_writeToBinaryFile(frontmtx: *mut FrontMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_writeStats(frontmtx: *mut FrontMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_writeForHumanEye(frontmtx: *mut FrontMtx, fp: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn FrontMtx_writeForMatlab(
        frontmtx: *mut FrontMtx,
        Lname: *mut libc::c_char,
        Dname: *mut libc::c_char,
        Uname: *mut libc::c_char,
        fp: *mut FILE,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
